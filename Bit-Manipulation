ğŸ”¢ Bit Manipulation in Java (In-Depth Guide)
================================================
Q: Bit : Bits are values in the form of 0 and 1 (binary form).

ğŸ”¹ Bits in Java (Interview Point)
| Data Type | Size (Bytes)  | Size (Bits)   | Range (Numeric Form)                                        |
| --------- | ------------- | ------------- | ----------------------------------------------------------- |
| `byte`    | 1 byte        | 8 bits        |   âˆ’128 to 127                                               |
| `short`   | 2 bytes       | 16 bits       |   âˆ’32,768 to 32,767                                         |
| `int`     | 4 bytes       | 32 bits       |   âˆ’2,147,483,648 to 2,147,483,647                           |
| `long`    | 8 bytes       | 64 bits       |   âˆ’9,223,372,036,854,775,808 to 9,223,372,036,854,775,807   |
| `char`    | 2 bytes       | 16 bits       |   0 to 65,535                                               |
| `boolean` | JVM dependent | JVM dependent |   true / false                                              |
| `float`   | 4 bytes       | 32 bits       |   ~1.4Eâˆ’45 to 3.4028235E38                                  |
| `double`  | 8 bytes       | 64 bits       |   ~4.9Eâˆ’324 to 1.7976931348623157E308                       |


ğŸ”¹ Bit vs Byte (Very Important) 
| Bit           | Byte              |
| ------------- | ----------------- |
| Single 0 or 1 | Group of 8 bits   |
| Smallest unit | Basic memory unit |

1ï¸âƒ£ What is Bit Manipulation?
------------------------------------
--> Bit manipulation means working directly with binary bits (0s and 1s) of numbers using bitwise operators.
--> ğŸ‘‰ Computers store everything in binary
--> ğŸ‘‰ Operations at bit level are very fast
--> ğŸ‘‰ Used in:
           1. DSA problems
           2. Optimization
           3. Cryptography
           4. Low-level systems
           5. Competitive programming

2ï¸âƒ£ Binary Representation Basics
--------------------------------
| Decimal | Binary |
| ------- | ------ |
| 0       | 0000   |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |

Example: int n = 5; // binary: 0101

3ï¸âƒ£ Java Inbuilt Bit Utilities
---------------------------------
1. Integer.toBinaryString(n);
--> Converts an integer (decimal) into its binary string representation.
--> It returns a String, not a number.
Ex: 1
int n = 13;
System.out.println(Integer.toBinaryString(n));
Output : 1101

Ex: 2
   Scanner sc = new Scanner(System.in);
   System.out.print("Enter a decimal number: ");
   int n = sc.nextInt();
   String binary = Integer.toBinaryString(n);
   System.out.println("Binary: " + binary);

2. Integer.bitCount(n);
3. Integer.highestOneBit(n);
4. Integer.lowestOneBit(n);

1ï¸âƒ£ Convert Decimal to Binary (Interview Explanation)
--> To convert a decimal number to binary:
     1. Divide the number by 2
     2. Store the remainder
     3. Repeat until number becomes 0
     4. Read remainders in reverse order

Example: Decimal = 13
13 Ã· 2 = 6  â†’ rem 1
6  Ã· 2 = 3  â†’ rem 0
3  Ã· 2 = 1  â†’ rem 1
1  Ã· 2 = 0  â†’ rem 1
Binary = 1101

Q: convert Decimal to binary Using While Loop (Most Asked in Interview)?
Ex: 
import java.util.Scanner;
public class DecimalToBinary {
    public static String decimalToBinary(int n) {

        // Edge case: if user enters 0
        if (n == 0) {
            return "0";
        }
   
        String binary = "";              // Empty string to store binary result
        
        while (n >= 1) {                // Loop until all binary digits are processed
            binary = (n % 2) + binary; // Get last binary digit
            n = n / 2;                 // Remove last binary digit
        }
        return binary;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a decimal number: ");
        int n = sc.nextInt();

        System.out.println("Binary: " + decimalToBinary(n));
        sc.close();
    }
}

Visual Table: 
| n  | n % 2 | binary | n / 2 |
| -- | ----- | ------ | ----- |
| 13 | 1     | "1"    | 6     |
| 6  | 0     | "01"   | 3     |
| 3  | 1     | "101"  | 1     |
| 1  | 1     | "1101" | 0     |
--> â€œExtract the last binary digit using % 2, store it, and remove it using / 2 until number becomes zero.â€

2ï¸âƒ£ Binary to Decimal (Reverse of Decimal â†’ Binary)
--> To convert binary(1101) â†’ decimal(13) :
    1. Read binary digits from right to left
    2. Multiply each bit with power of 2
    3. Add all values
Formula: decimal = digit Ã— 2â° + digit Ã— 2Â¹ + digit Ã— 2Â² + ...

ğŸ§  Example : Binary: 1101
1 Ã— 2Â³ = 8
1 Ã— 2Â² = 4
0 Ã— 2Â¹ = 0
1 Ã— 2â° = 1
----------------
Decimal = 13

package com.userService;
import java.util.Scanner;
public class Practice {

    static int convertBinaryToDecimal(String b) {      // Takes binary number as String and Returns decimal number as int
        int decimal = 0;  // stores final answer
        int powerOf2 = 1; // This represents 2â° = 1, 2Â¹ = 2,2Â² = 4,2Â³ = 8 the value of the rightmost bit
 
        for (int i = b.length() - 1; i >= 0; i--) { // Binary calculation starts from RIGHT to LEFT & Rightmost digit = lowest power (2â°)
            if (b.charAt(i) == '1') {              // 1. '1' Ã— powerOf2 = value â†’ add it  2. '0' Ã— powerOf2 = 0 â†’ no effect
                decimal = decimal + powerOf2;     // If digit is '1', add its weight to decimal.
            }
            powerOf2 = powerOf2 * 2;              // Move to Next Power of 2 like this : 1 â†’ 2 â†’ 4 â†’ 8 â†’ 16 ...
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the Binary number: ");
        String b = scan.next();   
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        scan.close();
    }
}
Table : Dry Run Example (Binary = 1101)
| Digit | powerOf2 | decimal |
| ----- | -------- | ------- |
| 1     | 1        | 1       |
| 0     | 2        | 1       |
| 1     | 4        | 5       |
| 1     | 8        | 13      |
--> â€œI traverse the binary string from right to left, multiply each bit with the corresponding power of 2, and add it to the decimal result.â€

second Approach : most Efficient approach 
---------------
import java.util.Scanner;
public class BinaryToDecimal {
    static int convertBinaryToDecimal(String b) {          // used String because binary digits are characters ('0' and '1').
        int decimal = 0;

        for (int i = 0; i < b.length(); i++) {             // Binary: 1101 , Index : 0 1 2 3

            decimal = decimal * 2 + (b.charAt(i) - '0');  // decimal = decimal * 2 + digit;
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the Binary number: ");
        String b = sc.next();   // Example input: 1101
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        sc.close();
    }
}
FULL DRY RUN (Binary = "1101")
| i | b.charAt(i) | decimal * 2 | digit | new decimal |
| - | ----------- | ----------- | ----- | ----------- |
| 0 | '1'         | 0 Ã— 2 = 0   | 1     | 1           |
| 1 | '1'         | 1 Ã— 2 = 2   | 1     | 3           |
| 2 | '0'         | 3 Ã— 2 = 6   | 0     | 6           |
| 3 | '1'         | 6 Ã— 2 = 12  | 1     | 13          |


ğŸ”¹ Part 1: decimal * 2
--> ğŸ‘‰ Binary is base-2
--> Multiplying by 2 means:
      1. Shift previous value left by 1 bit
      2. Prepare space for the next digit

ğŸ”¹ Part 2: (b.charAt(i) - '0')
Suppose : b.charAt(i) == '1'
Then:
'1' - '0' = 1
'0' - '0' = 0
ğŸ‘‰ Converts character to number

Part 3: Add them
decimal = decimal * 2 + digit;
ğŸ‘‰ This adds the current binary digit to decimal value.

Q: How are Negative Numbers Stored in Binary?
=============================================
--> Computers store negative numbers using Twoâ€™s Complement representation.

Step-by-Step: Twoâ€™s Complement Method
--------------------------------------
Rule : To store âˆ’N in binary:
1ï¸âƒ£ Write binary of +N
2ï¸âƒ£ Take 1â€™s complement (invert bits)
3ï¸âƒ£ Add 1

Example 1: Store âˆ’5 in 8-bit Binary
Step 1: Binary of +5
5  = 00000101

Step 2: 1â€™s Complement (invert bits)
00000101
--------
11111010

Step 3: Add 1
11111010
+       1
---------
11111011
--> âœ… âˆ’5 = 11111011 (in 8-bit twoâ€™s complement)

Q: How to Identify a Negative Number?
--> ğŸ‘‰ MSB (Most Significant Bit)
| MSB | Meaning         |
| --- | --------------- |
| 0   | Positive number |
| 1   | Negative number |
Ex: 
1. Positive Number (+5) : 
00000101
â†‘
MSB = 0 â†’ Positive

2. Negative Number (âˆ’5)
11111011
â†‘
MSB = 1 â†’ Negative

Q: How to Convert Back (Binary â†’ Decimal)?
If MSB = 1 (negative):
    1ï¸âƒ£ Take 1â€™s complement
    2ï¸âƒ£ Add 1
    3ï¸âƒ£ Put negative sign
Example:
11111011
â†“ invert
00000100
â†“ +1
00000101 = 5

Q. Range of Values (Very Important)
--> For n bits:
--> Range = -2^(n-1)  to  +2^(n-1) - 1
--> Example: 8-bit
--> -128  to  +127

ğŸ”¹ Bitwise Operators in Java 
====================================
| Operator             | Symbol | Meaning                 |                   |
| -------------------- | ------ | ----------------------- | ----------------- |
| AND                  | `&`    | 1 if both bits are 1    |                   |
| OR                   | `      | `                       | 1 if any bit is 1 |
| XOR                  | `^`    | 1 if bits are different |                   |
| NOT                  | `~`    | Inverts bits            |                   |
| Left Shift           | `<<`   | Multiply by 2           |                   |
| Right Shift          | `>>`   | Divide by 2             |                   |
| Unsigned Right Shift | `>>>`  | Fill with 0             |                   |

1ï¸âƒ£ Bitwise AND (&) : Both bits must be 1
âœ… Truth Table
| A | B | A & B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |
Ex: 
int a = 5;   // 0101
int b = 3;   // 0011
System.out.println(a & b); // 1

ğŸ§  Logic: 
  0101
& 0011
------
  0001  â†’ 1
--> Used in: 1.Security  2.Role-based access  3.Feature toggles

2ï¸âƒ£ Bitwise OR (|) : Any bit is 1 â†’ result 1
âœ… Truth Table
| A | B | A | B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 1     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a | b); // 7

ğŸ§  Logic:
  0101
| 0011
------
  0111 â†’ 7

ğŸ”¥ Real-Time Use : âœ” Enable Features
int DARK_MODE = 1;
int NOTIFICATIONS = 2;
int settings = DARK_MODE | NOTIFICATIONS;

--> Used in: 1.Configuration flags   2.Logging levels   3.System properties

3ï¸âƒ£ Bitwise XOR (^) : Different bits â†’ 1 (Both Same â†’ 0 , Both Different â†’ 1)
âœ… Truth Table
| A | B | A ^ B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 0     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a ^ b); // 6

ğŸ§  Logic:
  0101
^ 0011
------
  0110 â†’ 6

ğŸ”¥ Real-Time Use : 
1. âœ” Swap Two Numbers (No Temp Variable)
int a = 10, b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;

2. âœ” Find Unique Element : Very common in DSA interviews
int[] arr = {2, 3, 2, 4, 4};
int res = 0;

for (int x : arr)
    res ^= x;
System.out.println(res); // 3

4ï¸âƒ£ Bitwise NOT (~)
âœ… Truth Table
| A | ~A |
| - | -- |
| 0 | 1  |
| 1 | 0  |
Ex: 
int a = 5;
System.out.println(~a);

 5  = 00000000 00000000 00000000 00000101
~5 = 11111111 11111111 11111111 11111010 â†’ -6

ğŸ§  Logic : ~n = -(n + 1)  // formula to calculate directly

Real-Time Use : 1.Bit masking  2.Clearing flags  3.Low-level operations
Ex : int mask = ~READ;

5ï¸âƒ£ Left Shift (<<) : 
Ex : 
int a = 5;
System.out.println(a << 1); // 10

5 = 00000101
<<1
---------
10 = 00001010

ğŸ§  Logic : a << n = a Ã— 2â¿

ğŸ”¥ Real-Time Use : 1.Fast multiplication  2.Hashing  3.Bitmap indexing
Ex: int size = 1 << 10; // 1024

6ï¸âƒ£ Right Shift (>>) (Signed) : 1.Preserves sign bit  2.Fills with MSB
Ex: 
int a = -8;
System.out.println(a >> 1); // -4

-8 = 11111000
>>1
-----
-4 = 11111100

ğŸ”¥ Real-Time Use : 1.Division by 2   2.Arithmetic operations
Ex: int mid = (low + high) >> 1;
--> Used in Binary Search

7ï¸âƒ£ Unsigned Right Shift (>>>) : 1.Always fills with 0   2.Ignores sign
Ex: 
int a = -8;
System.out.println(a >>> 1);

11111000 >>> 1
= 01111100 â†’ large positive number

ğŸ”¥ Real-Time Use : 1.Hash functions  2.Binary data parsing  3.Cryptography
Ex: int hash = value >>> 16;

Interview Summary (Must Remember) : 
| Operator | Key Point       |           |
| -------- | --------------- | --------- |
| `&`      | Check flags     |           |
| `        | `               | Set flags |
| `^`      | Toggle / unique |           |
| `~`      | Invert bits     |           |
| `<<`     | Fast multiply   |           |
| `>>`     | Signed divide   |           |
| `>>>`    | Unsigned shift  |           |


Q: ğŸ”¹ What is Bit Masking?
=============================
--> Bit masking is a technique that uses bitwise operators to manipulate individual bits of an integer 
    for efficient storage, fast computation, and flag management.

--> It is commonly used in:
     1.Permissions
     2.Feature flags
     3.Performance-critical systems
     4.Low-level optimizations

ğŸ”¹ Why Do We Use Bit Masking?
--> Interview points:
    1.Saves memory (1 bit per state)
    2.Very fast (bitwise ops are O(1))
    3.Multiple states stored in one integer
    4.Cleaner than multiple booleans

ğŸ”¹ Interview Master Summary (Cheat Sheet)
| Task             | Formula       |         |
| ---------------- | ------------- | ------- |
| Check bit        | `n & (1<<i)`  |         |
| Set bit          | `n            | (1<<i)` |
| Clear bit        | `n & ~(1<<i)` |         |
| Toggle bit       | `n ^ (1<<i)`  |         |
| Odd/Even         | `n & 1`       |         |
| Power of 2       | `n&(n-1)`     |         |
| Clear lowest bit | `n&(n-1)`     |         |
| Rightmost bit    | `n & -n`      |         |

âœ… Basic Rules : Bits behave like electric switches.
Rule 1 : 0 â†’ OFF
Rule 2 : 1 â†’ ON

Rule 1 : 0 â†’ OFF
     |0|0|1|0|0|1|0|0|
OR(|)|0|0|0|0|0|0|0|0|
     ------------------
     |0|0|1|0|0|1|0|0|
Observation: zero(0) has not effect on bits

Rule 2 : 1 â†’ ON
     |0|0|1|0|0|1|0|0|
OR(|)|1|1|1|1|1|1|1|1|
     ------------------
     |1|1|1|1|1|1|1|1|
Observation: All off bits are turned on if we perform OR(|) operation with 1

Q 1: How to Switch ON the iáµ—Ê° Bit (Bit Masking) ?
--> ğŸ‘‰ To switch ON a bit, we use Bitwise OR ( | )
--> Formula (Must Remember) : n = n | (1 << i);

ğŸ§  How This Works (Logic)
--> (1 << i) creates a mask
--> That mask has only the iáµ—Ê° bit ON
--> OR (|) with 1 â†’ bit becomes ON
--> Other bits remain unchanged

Example : Switch ON the 3rd bit of: n = |0|0|1|0|0|1|0|0|

Step 1: Create mask
mask = 1 << 3; shifting 1 at 3rd index position from right to the left , which turn ON the bit at index 3.
  index :   7 6 5 4 3 2 1 0   --> Java uses 0-based indexing for counting from the right (LSB)  . 
1 << 3  â†’  |0|0|0|0|1|0|0|0|  --> Only the 3Ê³áµˆ bit is ON
Note: 
--> Although bits are written from left to right, bit indexing in Java is always counted from the rightmost (LSB), starting at 0.

Step 2: OR operation with two rule first check which bit should change and which bit unchange.                             
      |0|0|1|0|0|1|0|0|
OR(|) |0|0|0|0|1|0|0|0| --> mask: (1 << i) and 3rd index left shift <i<<3) 0 0 0      
 ------------------------------------------------------------------
      |0|0|1|0|1|1|0|0|
Observation : Only the 3rd bit is switched ON, all other bits remain same

Ex 1 : 
int n = 36;   // 00100100
int i = 3;   // 
int maskON = 1 << i
System.out.println(n | maskON); // 44 (00101100)

// or,
// n = n | (1 << i);
// System.out.println(n); // 44 (00101100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = 0;

// switch ON WRITE permission
userPerm = userPerm | WRITE;

Q 2: How to Switch OFF the iáµ—Ê° Bit (Bit Masking) ?
--> ğŸ‘‰ To switch OFF a bit, we use Bitwise AND (&) with NOT (~)
--> Formula : n = n & ~(1 << i);

Q: How This Works (Logic)
1. (1 << i) : creates a mask with only the iáµ—Ê° bit ON

2. ~(1 << i) : flips the mask â†’ iáµ—Ê° bit becomes OFF, others ON

3. n & mask : 
  â†’ AND with 0 turns OFF that bit
  â†’ AND with 1 keeps other bits unchanged

Example : Switch OFF the 3Ê³áµˆ bit of: n = |0|0|1|0|1|1|0|0|
                                           7 6 5 4 3 2 1 0
Step 1: Create Mask : 
 1 << 3  â†’  |0|0|0|0|1|0|0|0|

Step 2: Invert Mask :
 ~(1 << 3) â†’ |1|1|1|1|0|1|1|1|

Step 3: AND Operation : 
      |0|0|1|0|1|1|0|0|
AND(&)|1|1|1|1|0|1|1|1|
      ------------------
      |0|0|1|0|0|1|0|0|
--> Observation : Only the 3Ê³áµˆ bit is switched OFF, all other bits remain unchanged

Ex: 
int n = 44;   // 00101100
int i = 3;

int maskOFF = 1 << i;
int flips = ~(1 << i);
System.out.println(n & flips); // 36

//Or using formula
//n = n & ~(1 << i);
//System.out.println(n); // 36 (00100100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = READ | WRITE; // both ON

// switch OFF WRITE permission
userPerm = userPerm & ~WRITE;

Q 3 : How to Toggle the iáµ—Ê° Bit (Bit Masking) ?
Q: What does TOGGLE mean : ğŸ‘‰ Toggle = flip the bit
0 â†’ 1  (OFF â†’ ON)
1 â†’ 0  (ON â†’ OFF)

ğŸ”¹ Operator Used : Bitwise XOR (^)
Why XOR?
| Bit | XOR 0         | XOR 1    |
| --- | ------------- | -------- |
| 0   | 0 (no change) | 1 (flip) |
| 1   | 1 (no change) | 0 (flip) |
--> ğŸ‘‰ XOR with 1 toggles the bit
Formula : n = n ^ (1 << i);

Q: How This Works (Logic) ?
  1. (1 << i) â†’ creates a mask with only the iáµ—Ê° bit ON
  2. XOR (^) with:
       (a). 1 â†’ flips the bit
       (b). 0 â†’ keeps the bit unchanged
Ex : 
Toggle the 3Ê³áµˆ bit of:n = |0|0|1|0|1|1|0|0|   (44)
                            7 6 5 4 3 2 1 0
Step 1: Create Mask
  1 << 3 â†’ |0|0|0|0|1|0|0|0|

Step 2: XOR Operation
      |0|0|1|0|1|1|0|0|
XOR(^)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|1|0|0|1|0|0|

Observation : The 3Ê³áµˆ bit changes from 1 â†’ 0, all other bits remain unchanged

Java Ex: 
int n = 44;   // 00101100
int i = 3;

int maskToggle = 1 << i;
System.out.println(n ^ maskToggle); // 36

// or using formula
// n = n ^ (1 << i);
// System.out.println(n); // 36 (00100100)

Toggle Again (Proof) : 
n = n ^ (1 << i);
System.out.println(n); // 44

Ex: Real-Time Use Case : 
int DARK_MODE = 1 << 2;
settings ^= DARK_MODE;

Q 3 : How to check the iáµ—Ê° Bit (Bit Masking) ?
Q: What does CHECK mean? 
-->  We want to know whether the iáµ—Ê° bit is 1 (ON) or 0 (OFF) .
-->  We do NOT change the number .

ğŸ”¹ Operator Used : Bitwise AND (&)
Why AND?
  1. AND with 1 â†’ keeps bit value
  2. AND with 0 â†’ result becomes 0

ğŸ“Œ Formula : (n & (1 << i)) != 0

ğŸ§  How This Works (Logic)?
   1. (1 << i) creates a mask
     --> only the iáµ—Ê° bit is ON

   2. AND (&) operation:
     --> If iáµ—Ê° bit in n is 1 â†’ result â‰  0
     --> If iáµ—Ê° bit in n is 0 â†’ result = 0
Ex :
Check the 3Ê³áµˆ bit of:n = |0|0|1|0|1|1|0|0|   (44)
                           7 6 5 4 3 2 1 0
Step 1: Create Mask
1 << 3 â†’ |0|0|0|0|1|0|0|0|

Step 2: AND Operation
      |0|0|1|0|1|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|0|0|1|0|0|0|
--> Observation : Result is non-zero â†’ 3Ê³áµˆ bit is ON

âŒ If Bit Was OFF
n = |0|0|1|0|0|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
---------------------
      |0|0|0|0|0|0|0|0|
ğŸ“Œ Result = 0 â†’ bit is OFF

Java Ex 1: 
int n = 44;   // 00101100
int i = 3;
boolean isON = (n & (1 << i)) != 0;
System.out.println(isON); // true

java Ex 2 : 
int n = 44;   // 00101100
int i = 3;

int checkMass = 1 << i ;

if((n & checkMass) == 0) {
System.out.println("isOFF");
}else{
System.out.println("isON");
}
// or
// boolean isOFF = (n & (1 << i)) == 0;
// System.out.println(isOFF); // false

Ex 3 : Real-Time Use Case (Permissions)
int READ  = 1 << 0;
int WRITE = 1 << 1;

int userPerm = READ | WRITE;
// check WRITE permission
if ((userPerm & WRITE) != 0) {
    System.out.println("Write allowed");
}

ğŸ§  Final Memory Rule : 
| Operation | Condition |
| --------- | --------- |
| Bit ON    | `!= 0`    |
| Bit OFF   | `== 0`    |

Q: Find the Position of Rightmost Set Bit (Without Built-ins) ?
Ex 1 : 
import java.util.Scanner;
public class Bitwise {

    // Returns 1-based position of Right Most Set Bit
    static int positionOfRMSB(int n) {
        if (n == 0) {
            return -1; // no set bits
        }

        int pos = 1;
        while ((n & 1) == 0) {
            n >>= 1;
            pos++;
        }
        return pos;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        int pos = positionOfRMSB(n);
        if (pos == -1) {
            System.out.println("No set bits present");
        } else {
            System.out.println("Position of Rightmost Set Bit: " + pos);
        }
        scan.close();
    }
}

Ex 2 : Q: Find the Position of Rightmost Set Bit (With Built-ins) ? 
import java.util.Scanner;
public class Bitwise {

    // Returns 1-based position of Right Most Set Bit
    static int positionOfRMSB(int n) {
        if (n == 0) {
            return -1; // no set bit
        }
        return Integer.numberOfTrailingZeros(n) + 1;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        int pos = positionOfRMSB(n);
        if (pos == -1) {
            System.out.println("No set bits present");
        } else {
            System.out.println("Position of Rightmost Set Bit: " + pos);
        }
        scan.close();
    }
}

Q: Count the number of set bit in a given number using Brian Kernighanâ€™s Algorithm ?
--> Idea : Each iteration removes the rightmost set bit.
--> Formula : n = n & (n - 1);
--> Example
       n = 44 â†’ 00101100
--> Steps:
      00101100  (44)
      00101000  (n & (n-1))
      00100000
      00000000
--> Set bits count = 3 ( three times removed 1 ) 
java Ex: 
import java.util.Scanner;
public class Bitwise {
    static int countSetBits(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1); // removes rightmost set bit
            count++;
        }
        return count;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        System.out.println("Number of set bits: " + countSetBits(n));
        scan.close();
    }
}

Q: Write a program to find whether a number is a power of 2 ? (Adobe Interview Question_PowerOf2) 
--> A number is a power of 2 if it has exactly one set bit in its binary representation.
--> Formula : n & (n - 1) // Brian Kernighanâ€™s Algorithm
--> Clears the rightmost set bit
--> If the result becomes 0, the number had only one set bit

java Ex: 
import java.util.Scanner;
public class Bitwise {
    static boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        if (isPowerOfTwo(n)) {
            System.out.println(n + " is a power of 2");
        } else {
            System.out.println(n + " is NOT a power of 2");
        }
        scan.close();
    }
}

ğŸ”¹ Find the Lonely(unique) Integer (vvi)
Q: Given an array where every element appears twice except one, find the element that appears only once.
ğŸ§  Key Idea : XOR Properties
               a ^ a = 0
               a ^ 0 = a
ğŸ‘‰ When we XOR all elements:
               1. Pairs cancel out
               2. The unique (lonely) number remains
Most Efficient Approach (XOR) :  Time: O(n) and  Space: O(1)

java Ex: 
import java.util.Scanner;
public class LonelyInteger {
    static int findLonelyInteger(int[] arr) {
        int result = 0;

        for (int num : arr) {
            result ^= num;  // XOR operation
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();
        int[] arr = new int[n];

        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        System.out.println("Lonely Integer: " + findLonelyInteger(arr));
        scan.close();
    }
}

ğŸ”¹ Lonely Integer when Others Appear 3 Times
Q: Given an array where every element appears exactly 3 times except one element which appears only once, find that unique (lonely) number.
Note: 
--> Now XOR Alone Wonâ€™t Work Here 
--> Q: âŒ Why XOR Alone Wonâ€™t Work Here?
    Because:
         a ^ a ^ a = a   âŒ (not 0)
--> So duplicates do NOT cancel out when they appear 3 times.

ğŸ§  Efficient Concept (Interview Explanation)
--> Count bits at each position (0â€“31)
--> If a bit count is not divisible by 3, that bit belongs to the lonely number
--> ğŸ‘‰ This works because:
          1. Triplets contribute multiples of 3
          2. Lonely number contributes extra bits
âœ… Optimal Approach (Bit Counting)
â±  Time: O(32 Ã— n) â†’ O(n)
ğŸ§  Space: O(1)

java Ex : 
import java.util.Scanner;
public class LonelyIntegerThrice {

    static int findLonelyInteger(int[] arr) {
        int result = 0;

        // Check each bit position
        for (int bit = 0; bit < 32; bit++) {
            int count = 0;

            for (int num : arr) {
                if ((num & (1 << bit)) != 0) {
                    count++;
                }
            }
            // If count is not multiple of 3, set that bit
            if (count % 3 != 0) {
                result |= (1 << bit);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        System.out.println("Lonely Integer: " + findLonelyInteger(arr));
        scan.close();
    }
}
Input : 
7
2 2 3 2 4 4 4

Explanation :
2 â†’ appears 3 times
4 â†’ appears 3 times
3 â†’ appears once âœ…

Output : 
Lonely Integer: 3
Q: Can this handle negative numbers?
--> âœ”ï¸ YES, because Java uses twoâ€™s complement and we check all 32 bits.

ğŸ”¹ Find the Two Lonely Integers : (All other numbers appear twice)
Q: Given an array where exactly two numbers appear once and all other numbers appear twice, find the two unique numbers.

ğŸ§  Key Idea (Interview Explanation)
1. XOR all numbers â†’ duplicates cancel out
   xor = a ^ b
--> (a and b are the two lonely numbers)

2. Find rightmost set bit in xor
   rmsb = xor & (-xor)

3. Divide numbers into two groups
     (I).  Group 1 â†’ bit set
     (II). Group 2 â†’ bit not set

4. XOR each group separately â†’ get a and b

âœ… Optimal Solution
Time: O(n)
Space: O(1)
--> No extra data structures

java Ex: 
import java.util.Scanner;
public class TwoLonelyIntegers {

    static void findTwoLonely(int[] arr) {
        int xor = 0;

        // Step 1: XOR all elements
        for (int num : arr) {
            xor ^= num;
        }

        // Step 2: Find rightmost set bit
        int rmsb = xor & (-xor);

        int num1 = 0, num2 = 0;

        // Step 3: Divide into two groups
        for (int num : arr) {
            if ((num & rmsb) != 0) {
                num1 ^= num;
            } else {
                num2 ^= num;
            }
        }
        System.out.println("Lonely numbers are: " + num1 + " and " + num2);
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();

        int[] arr = new int[n];

        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        findTwoLonely(arr);
        scan.close();
    }
}
Input
6
2 4 7 9 2 4

XOR Flow
xor = 7 ^ 9
rmsb = 2

Output
Lonely numbers are: 7 and 9

ğŸ”¹ Find the Missing Number (Using XOR)
Q: Given an array containing n distinct numbers taken from the range 0 to n, find the missing number.

ğŸ§  Key Idea :
XOR Properties
a ^ a = 0
a ^ 0 = a

ğŸ‘‰ If we XOR:
    1.All numbers from 0 to n
    2.All numbers present in the array
â¡ï¸ All duplicates cancel out, leaving the missing number.

âœ… Optimal Approach
Time: O(n)
Space: O(1)
--> No extra memory

java Ex: 
import java.util.Scanner;
public class MissingNumber {

    static int findMissingNumber(int[] arr, int n) {
        int xor = 0;

        // XOR all numbers from 0 to n
        for (int i = 0; i <= n; i++) {
            xor ^= i;
        }

        // XOR all array elements
        for (int num : arr) {
            xor ^= num;
        }
        return xor;
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter n (range 0 to n): ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter array elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }

        System.out.println("Missing Number: " + findMissingNumber(arr, n));
        scan.close();
    }
}
Input
n = 5
Array = 0 1 3 4 5

XOR Flow
(0^1^2^3^4^5) ^ (0^1^3^4^5)
= 2

Output
Missing Number: 2

ğŸ”¹ Find the Missing AND Repeating Number
Q: Given an array of size n containing numbers from 1 to n, one number is missing and one number is repeating.
Find both numbers.

ğŸ§  Key Idea : 
     1. XOR all array elements with numbers 1..n
     2. Result = missing ^ repeating
     3. Find rightmost set bit to separate them
     4. XOR in two groups to get both numbers
     5. Decide which is missing and which is repeating

âœ…  Optimal Solution
Time: O(n)
Space: O(1)
--> No extra memory

java Ex : 
import java.util.Scanner;
public class MissingRepeating {

    static void findMissingAndRepeating(int[] arr, int n) {
        int xor = 0;

        // Step 1: XOR array and numbers 1..n
        for (int i = 0; i < n; i++) {
            xor ^= arr[i];
            xor ^= (i + 1);
        }

        // Step 2: Rightmost set bit
        int rmsb = xor & (-xor);

        int x = 0, y = 0;

        // Step 3: Divide into two groups
        for (int i = 0; i < n; i++) {
            if ((arr[i] & rmsb) != 0)
                x ^= arr[i];
            else
                y ^= arr[i];

            if (((i + 1) & rmsb) != 0)
                x ^= (i + 1);
            else
                y ^= (i + 1);
        }

        // Step 4: Identify which is missing/repeating
        int repeating = 0, missing = 0;
        for (int num : arr) {
            if (num == x) {
                repeating = x;
                missing = y;
                break;
            } else if (num == y) {
                repeating = y;
                missing = x;
                break;
            }
        }

        System.out.println("Repeating Number: " + repeating);
        System.out.println("Missing Number: " + missing);
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter n: ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter array elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }

        findMissingAndRepeating(arr, n);
        scan.close();
    }
}
Input
n = 5
Array = 1 2 2 4 5

Output
Repeating Number: 2
Missing Number: 3















