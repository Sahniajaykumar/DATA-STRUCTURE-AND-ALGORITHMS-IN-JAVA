ğŸ”¢ Bit Manipulation in Java (In-Depth Guide)
================================================
Q: Bit : Bits are values in the form of 0 and 1 (binary form).

ğŸ”¹ Bits in Java (Interview Point)
| Data Type | Size (Bytes)  | Size (Bits)   | Range (Numeric Form)                                        |
| --------- | ------------- | ------------- | ----------------------------------------------------------- |
| `byte`    | 1 byte        | 8 bits        |   âˆ’128 to 127                                               |
| `short`   | 2 bytes       | 16 bits       |   âˆ’32,768 to 32,767                                         |
| `int`     | 4 bytes       | 32 bits       |   âˆ’2,147,483,648 to 2,147,483,647                           |
| `long`    | 8 bytes       | 64 bits       |   âˆ’9,223,372,036,854,775,808 to 9,223,372,036,854,775,807   |
| `char`    | 2 bytes       | 16 bits       |   0 to 65,535                                               |
| `boolean` | JVM dependent | JVM dependent |   true / false                                              |
| `float`   | 4 bytes       | 32 bits       |   ~1.4Eâˆ’45 to 3.4028235E38                                  |
| `double`  | 8 bytes       | 64 bits       |   ~4.9Eâˆ’324 to 1.7976931348623157E308                       |


ğŸ”¹ Bit vs Byte (Very Important) 
| Bit           | Byte              |
| ------------- | ----------------- |
| Single 0 or 1 | Group of 8 bits   |
| Smallest unit | Basic memory unit |

1ï¸âƒ£ What is Bit Manipulation?
------------------------------------
--> Bit manipulation means working directly with binary bits (0s and 1s) of numbers using bitwise operators.
--> ğŸ‘‰ Computers store everything in binary
--> ğŸ‘‰ Operations at bit level are very fast
--> ğŸ‘‰ Used in:
           1. DSA problems
           2. Optimization
           3. Cryptography
           4. Low-level systems
           5. Competitive programming

2ï¸âƒ£ Binary Representation Basics
--------------------------------
| Decimal | Binary |
| ------- | ------ |
| 0       | 0000   |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |

Example: int n = 5; // binary: 0101

3ï¸âƒ£ Java Inbuilt Bit Utilities
---------------------------------
1. Integer.toBinaryString(n);
--> Converts an integer (decimal) into its binary string representation.
--> It returns a String, not a number.
Ex: 1
int n = 13;
System.out.println(Integer.toBinaryString(n));
Output : 1101

Ex: 2
   Scanner sc = new Scanner(System.in);
   System.out.print("Enter a decimal number: ");
   int n = sc.nextInt();
   String binary = Integer.toBinaryString(n);
   System.out.println("Binary: " + binary);

2. Integer.bitCount(n);
3. Integer.highestOneBit(n);
4. Integer.lowestOneBit(n);

1ï¸âƒ£ Convert Decimal to Binary (Interview Explanation)
--> To convert a decimal number to binary:
     1. Divide the number by 2
     2. Store the remainder
     3. Repeat until number becomes 0
     4. Read remainders in reverse order

Example: Decimal = 13
13 Ã· 2 = 6  â†’ rem 1
6  Ã· 2 = 3  â†’ rem 0
3  Ã· 2 = 1  â†’ rem 1
1  Ã· 2 = 0  â†’ rem 1
Binary = 1101

Q: convert Decimal to binary Using While Loop (Most Asked in Interview)?
Ex: 
import java.util.Scanner;
public class DecimalToBinary {
    public static String decimalToBinary(int n) {

        // Edge case: if user enters 0
        if (n == 0) {
            return "0";
        }
   
        String binary = "";              // Empty string to store binary result
        
        while (n >= 1) {                // Loop until all binary digits are processed
            binary = (n % 2) + binary; // Get last binary digit
            n = n / 2;                 // Remove last binary digit
        }
        return binary;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a decimal number: ");
        int n = sc.nextInt();

        System.out.println("Binary: " + decimalToBinary(n));
        sc.close();
    }
}

Visual Table: 
| n  | n % 2 | binary | n / 2 |
| -- | ----- | ------ | ----- |
| 13 | 1     | "1"    | 6     |
| 6  | 0     | "01"   | 3     |
| 3  | 1     | "101"  | 1     |
| 1  | 1     | "1101" | 0     |
--> â€œExtract the last binary digit using % 2, store it, and remove it using / 2 until number becomes zero.â€

2ï¸âƒ£ Binary to Decimal (Reverse of Decimal â†’ Binary)
--> To convert binary(1101) â†’ decimal(13) :
    1. Read binary digits from right to left
    2. Multiply each bit with power of 2
    3. Add all values
Formula: decimal = digit Ã— 2â° + digit Ã— 2Â¹ + digit Ã— 2Â² + ...

ğŸ§  Example : Binary: 1101
1 Ã— 2Â³ = 8
1 Ã— 2Â² = 4
0 Ã— 2Â¹ = 0
1 Ã— 2â° = 1
----------------
Decimal = 13

package com.userService;
import java.util.Scanner;
public class Practice {

    static int convertBinaryToDecimal(String b) {      // Takes binary number as String and Returns decimal number as int
        int decimal = 0;  // stores final answer
        int powerOf2 = 1; // This represents 2â° = 1, 2Â¹ = 2,2Â² = 4,2Â³ = 8 the value of the rightmost bit
 
        for (int i = b.length() - 1; i >= 0; i--) { // Binary calculation starts from RIGHT to LEFT & Rightmost digit = lowest power (2â°)
            if (b.charAt(i) == '1') {              // 1. '1' Ã— powerOf2 = value â†’ add it  2. '0' Ã— powerOf2 = 0 â†’ no effect
                decimal = decimal + powerOf2;     // If digit is '1', add its weight to decimal.
            }
            powerOf2 = powerOf2 * 2;              // Move to Next Power of 2 like this : 1 â†’ 2 â†’ 4 â†’ 8 â†’ 16 ...
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the Binary number: ");
        String b = scan.next();   
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        scan.close();
    }
}
Table : Dry Run Example (Binary = 1101)
| Digit | powerOf2 | decimal |
| ----- | -------- | ------- |
| 1     | 1        | 1       |
| 0     | 2        | 1       |
| 1     | 4        | 5       |
| 1     | 8        | 13      |
--> â€œI traverse the binary string from right to left, multiply each bit with the corresponding power of 2, and add it to the decimal result.â€

second Approach : most Efficient approach 
---------------
import java.util.Scanner;
public class BinaryToDecimal {
    static int convertBinaryToDecimal(String b) {          // used String because binary digits are characters ('0' and '1').
        int decimal = 0;

        for (int i = 0; i < b.length(); i++) {             // Binary: 1101 , Index : 0 1 2 3

            decimal = decimal * 2 + (b.charAt(i) - '0');  // decimal = decimal * 2 + digit;
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the Binary number: ");
        String b = sc.next();   // Example input: 1101
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        sc.close();
    }
}
FULL DRY RUN (Binary = "1101")
| i | b.charAt(i) | decimal * 2 | digit | new decimal |
| - | ----------- | ----------- | ----- | ----------- |
| 0 | '1'         | 0 Ã— 2 = 0   | 1     | 1           |
| 1 | '1'         | 1 Ã— 2 = 2   | 1     | 3           |
| 2 | '0'         | 3 Ã— 2 = 6   | 0     | 6           |
| 3 | '1'         | 6 Ã— 2 = 12  | 1     | 13          |


ğŸ”¹ Part 1: decimal * 2
--> ğŸ‘‰ Binary is base-2
--> Multiplying by 2 means:
      1. Shift previous value left by 1 bit
      2. Prepare space for the next digit

ğŸ”¹ Part 2: (b.charAt(i) - '0')
Suppose : b.charAt(i) == '1'
Then:
'1' - '0' = 1
'0' - '0' = 0
ğŸ‘‰ Converts character to number

Part 3: Add them
decimal = decimal * 2 + digit;
ğŸ‘‰ This adds the current binary digit to decimal value.

Q: How are Negative Numbers Stored in Binary?
=============================================
--> Computers store negative numbers using Twoâ€™s Complement representation.

Step-by-Step: Twoâ€™s Complement Method
--------------------------------------
Rule : To store âˆ’N in binary:
1ï¸âƒ£ Write binary of +N
2ï¸âƒ£ Take 1â€™s complement (invert bits)
3ï¸âƒ£ Add 1

Example 1: Store âˆ’5 in 8-bit Binary
Step 1: Binary of +5
5  = 00000101

Step 2: 1â€™s Complement (invert bits)
00000101
--------
11111010

Step 3: Add 1
11111010
+       1
---------
11111011
--> âœ… âˆ’5 = 11111011 (in 8-bit twoâ€™s complement)

Q: How to Identify a Negative Number?
--> ğŸ‘‰ MSB (Most Significant Bit)
| MSB | Meaning         |
| --- | --------------- |
| 0   | Positive number |
| 1   | Negative number |
Ex: 
1. Positive Number (+5) : 
00000101
â†‘
MSB = 0 â†’ Positive

2. Negative Number (âˆ’5)
11111011
â†‘
MSB = 1 â†’ Negative

Q: How to Convert Back (Binary â†’ Decimal)?
If MSB = 1 (negative):
    1ï¸âƒ£ Take 1â€™s complement
    2ï¸âƒ£ Add 1
    3ï¸âƒ£ Put negative sign
Example:
11111011
â†“ invert
00000100
â†“ +1
00000101 = 5

Q. Range of Values (Very Important)
--> For n bits:
--> Range = -2^(n-1)  to  +2^(n-1) - 1
--> Example: 8-bit
--> -128  to  +127

ğŸ”¹ Bitwise Operators in Java 
====================================
| Operator             | Symbol | Meaning                 |                   |
| -------------------- | ------ | ----------------------- | ----------------- |
| AND                  | `&`    | 1 if both bits are 1    |                   |
| OR                   | `      | `                       | 1 if any bit is 1 |
| XOR                  | `^`    | 1 if bits are different |                   |
| NOT                  | `~`    | Inverts bits            |                   |
| Left Shift           | `<<`   | Multiply by 2           |                   |
| Right Shift          | `>>`   | Divide by 2             |                   |
| Unsigned Right Shift | `>>>`  | Fill with 0             |                   |

1ï¸âƒ£ Bitwise AND (&) : Both bits must be 1
âœ… Truth Table
| A | B | A & B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |
Ex: 
int a = 5;   // 0101
int b = 3;   // 0011
System.out.println(a & b); // 1

ğŸ§  Logic: 
  0101
& 0011
------
  0001  â†’ 1
--> Used in: 1.Security  2.Role-based access  3.Feature toggles

2ï¸âƒ£ Bitwise OR (|) : Any bit is 1 â†’ result 1
âœ… Truth Table
| A | B | A | B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 1     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a | b); // 7

ğŸ§  Logic:
  0101
| 0011
------
  0111 â†’ 7

ğŸ”¥ Real-Time Use : âœ” Enable Features
int DARK_MODE = 1;
int NOTIFICATIONS = 2;
int settings = DARK_MODE | NOTIFICATIONS;

--> Used in: 1.Configuration flags   2.Logging levels   3.System properties

3ï¸âƒ£ Bitwise XOR (^) : Different bits â†’ 1 (Both Same â†’ 0 , Both Different â†’ 1)
âœ… Truth Table
| A | B | A ^ B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 0     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a ^ b); // 6

ğŸ§  Logic:
  0101
^ 0011
------
  0110 â†’ 6

ğŸ”¥ Real-Time Use : 
1. âœ” Swap Two Numbers (No Temp Variable)
int a = 10, b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;

2. âœ” Find Unique Element : Very common in DSA interviews
int[] arr = {2, 3, 2, 4, 4};
int res = 0;

for (int x : arr)
    res ^= x;
System.out.println(res); // 3

4ï¸âƒ£ Bitwise NOT (~)
âœ… Truth Table
| A | ~A |
| - | -- |
| 0 | 1  |
| 1 | 0  |
Ex: 
int a = 5;
System.out.println(~a);

 5  = 00000000 00000000 00000000 00000101
~5 = 11111111 11111111 11111111 11111010 â†’ -6

ğŸ§  Logic : ~n = -(n + 1)  // formula to calculate directly

Real-Time Use : 1.Bit masking  2.Clearing flags  3.Low-level operations
Ex : int mask = ~READ;

5ï¸âƒ£ Left Shift (<<) : 
Ex : 
int a = 5;
System.out.println(a << 1); // 10

5 = 00000101
<<1
---------
10 = 00001010

ğŸ§  Logic : a << n = a Ã— 2â¿

ğŸ”¥ Real-Time Use : 1.Fast multiplication  2.Hashing  3.Bitmap indexing
Ex: int size = 1 << 10; // 1024

6ï¸âƒ£ Right Shift (>>) (Signed) : 1.Preserves sign bit  2.Fills with MSB
Ex: 
int a = -8;
System.out.println(a >> 1); // -4

-8 = 11111000
>>1
-----
-4 = 11111100

ğŸ”¥ Real-Time Use : 1.Division by 2   2.Arithmetic operations
Ex: int mid = (low + high) >> 1;
--> Used in Binary Search

7ï¸âƒ£ Unsigned Right Shift (>>>) : 1.Always fills with 0   2.Ignores sign
Ex: 
int a = -8;
System.out.println(a >>> 1);

11111000 >>> 1
= 01111100 â†’ large positive number

ğŸ”¥ Real-Time Use : 1.Hash functions  2.Binary data parsing  3.Cryptography
Ex: int hash = value >>> 16;

Interview Summary (Must Remember) : 
| Operator | Key Point       |           |
| -------- | --------------- | --------- |
| `&`      | Check flags     |           |
| `        | `               | Set flags |
| `^`      | Toggle / unique |           |
| `~`      | Invert bits     |           |
| `<<`     | Fast multiply   |           |
| `>>`     | Signed divide   |           |
| `>>>`    | Unsigned shift  |           |


Q: ğŸ”¹ What is Bit Masking?
=============================
--> Bit masking is a technique that uses bitwise operators to manipulate individual bits of an integer 
    for efficient storage, fast computation, and flag management.

--> It is commonly used in:
     1.Permissions
     2.Feature flags
     3.Performance-critical systems
     4.Low-level optimizations

ğŸ”¹ Why Do We Use Bit Masking?
--> Interview points:
    1.Saves memory (1 bit per state)
    2.Very fast (bitwise ops are O(1))
    3.Multiple states stored in one integer
    4.Cleaner than multiple booleans

ğŸ”¹ Interview Master Summary (Cheat Sheet)
| Task             | Formula       |         |
| ---------------- | ------------- | ------- |
| Check bit        | `n & (1<<i)`  |         |
| Set bit          | `n            | (1<<i)` |
| Clear bit        | `n & ~(1<<i)` |         |
| Toggle bit       | `n ^ (1<<i)`  |         |
| Odd/Even         | `n & 1`       |         |
| Power of 2       | `n&(n-1)`     |         |
| Clear lowest bit | `n&(n-1)`     |         |
| Rightmost bit    | `n & -n`      |         |

âœ… Basic Rules : Bits behave like electric switches.
Rule 1 : 0 â†’ OFF
Rule 2 : 1 â†’ ON

Rule 1 : 0 â†’ OFF
     |0|0|1|0|0|1|0|0|
OR(|)|0|0|0|0|0|0|0|0|
     ------------------
     |0|0|1|0|0|1|0|0|
Observation: zero(0) has not effect on bits

Rule 2 : 1 â†’ ON
     |0|0|1|0|0|1|0|0|
OR(|)|1|1|1|1|1|1|1|1|
     ------------------
     |1|1|1|1|1|1|1|1|
Observation: All off bits are turned on if we perform OR(|) operation with 1

Q 1: How to Switch ON the iáµ—Ê° Bit (Bit Masking) ?
--> ğŸ‘‰ To switch ON a bit, we use Bitwise OR ( | )
--> Formula (Must Remember) : n = n | (1 << i);

ğŸ§  How This Works (Logic)
--> (1 << i) creates a mask
--> That mask has only the iáµ—Ê° bit ON
--> OR (|) with 1 â†’ bit becomes ON
--> Other bits remain unchanged

Example : Switch ON the 3rd bit of: n = |0|0|1|0|0|1|0|0|

Step 1: Create mask
mask = 1 << 3; shifting 1 at 3rd index position from right to the left , which turn ON the bit at index 3.
  index :   7 6 5 4 3 2 1 0   --> Java uses 0-based indexing for counting from the right (LSB)  . 
1 << 3  â†’  |0|0|0|0|1|0|0|0|  --> Only the 3Ê³áµˆ bit is ON
Note: 
--> Although bits are written from left to right, bit indexing in Java is always counted from the rightmost (LSB), starting at 0.

Step 2: OR operation with two rule first check which bit should change and which bit unchange.                             
      |0|0|1|0|0|1|0|0|
OR(|) |0|0|0|0|1|0|0|0| --> mask: (1 << i) and 3rd index left shift <i<<3) 0 0 0      
 ------------------------------------------------------------------
      |0|0|1|0|1|1|0|0|
Observation : Only the 3rd bit is switched ON, all other bits remain same

Ex 1 : 
int n = 36;   // 00100100
int i = 3;   // 
int maskON = 1 << i
System.out.println(n | maskON); // 44 (00101100)

// or,
// n = n | (1 << i);
// System.out.println(n); // 44 (00101100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = 0;

// switch ON WRITE permission
userPerm = userPerm | WRITE;

Q 2: How to Switch OFF the iáµ—Ê° Bit (Bit Masking) ?
--> ğŸ‘‰ To switch OFF a bit, we use Bitwise AND (&) with NOT (~)
--> Formula : n = n & ~(1 << i);

Q: How This Works (Logic)
1. (1 << i) : creates a mask with only the iáµ—Ê° bit ON

2. ~(1 << i) : flips the mask â†’ iáµ—Ê° bit becomes OFF, others ON

3. n & mask : 
  â†’ AND with 0 turns OFF that bit
  â†’ AND with 1 keeps other bits unchanged

Example : Switch OFF the 3Ê³áµˆ bit of: n = |0|0|1|0|1|1|0|0|
                                           7 6 5 4 3 2 1 0
Step 1: Create Mask : 
 1 << 3  â†’  |0|0|0|0|1|0|0|0|

Step 2: Invert Mask :
 ~(1 << 3) â†’ |1|1|1|1|0|1|1|1|

Step 3: AND Operation : 
      |0|0|1|0|1|1|0|0|
AND(&)|1|1|1|1|0|1|1|1|
      ------------------
      |0|0|1|0|0|1|0|0|
--> Observation : Only the 3Ê³áµˆ bit is switched OFF, all other bits remain unchanged

Ex: 
int n = 44;   // 00101100
int i = 3;

int maskOFF = 1 << i;
int flips = ~(1 << i);
System.out.println(n & flips); // 36

//Or using formula
//n = n & ~(1 << i);
//System.out.println(n); // 36 (00100100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = READ | WRITE; // both ON

// switch OFF WRITE permission
userPerm = userPerm & ~WRITE;

Q 3 : How to Toggle the iáµ—Ê° Bit (Bit Masking) ?
Q: What does TOGGLE mean : ğŸ‘‰ Toggle = flip the bit
0 â†’ 1  (OFF â†’ ON)
1 â†’ 0  (ON â†’ OFF)

ğŸ”¹ Operator Used : Bitwise XOR (^)
Why XOR?
| Bit | XOR 0         | XOR 1    |
| --- | ------------- | -------- |
| 0   | 0 (no change) | 1 (flip) |
| 1   | 1 (no change) | 0 (flip) |
--> ğŸ‘‰ XOR with 1 toggles the bit
Formula : n = n ^ (1 << i);

Q: How This Works (Logic) ?
  1. (1 << i) â†’ creates a mask with only the iáµ—Ê° bit ON
  2. XOR (^) with:
       (a). 1 â†’ flips the bit
       (b). 0 â†’ keeps the bit unchanged
Ex : 
Toggle the 3Ê³áµˆ bit of:n = |0|0|1|0|1|1|0|0|   (44)
                            7 6 5 4 3 2 1 0
Step 1: Create Mask
  1 << 3 â†’ |0|0|0|0|1|0|0|0|

Step 2: XOR Operation
      |0|0|1|0|1|1|0|0|
XOR(^)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|1|0|0|1|0|0|

Observation : The 3Ê³áµˆ bit changes from 1 â†’ 0, all other bits remain unchanged

Java Ex: 
int n = 44;   // 00101100
int i = 3;

int maskToggle = 1 << i;
System.out.println(n ^ maskToggle); // 36

// or using formula
// n = n ^ (1 << i);
// System.out.println(n); // 36 (00100100)

Toggle Again (Proof) : 
n = n ^ (1 << i);
System.out.println(n); // 44

Ex: Real-Time Use Case : 
int DARK_MODE = 1 << 2;
settings ^= DARK_MODE;

Q 3 : How to check the iáµ—Ê° Bit (Bit Masking) ?
Q: What does CHECK mean? 
-->  We want to know whether the iáµ—Ê° bit is 1 (ON) or 0 (OFF) .
-->  We do NOT change the number .

ğŸ”¹ Operator Used : Bitwise AND (&)
Why AND?
  1. AND with 1 â†’ keeps bit value
  2. AND with 0 â†’ result becomes 0

ğŸ“Œ Formula : (n & (1 << i)) != 0

ğŸ§  How This Works (Logic)?
   1. (1 << i) creates a mask
     --> only the iáµ—Ê° bit is ON

   2. AND (&) operation:
     --> If iáµ—Ê° bit in n is 1 â†’ result â‰  0
     --> If iáµ—Ê° bit in n is 0 â†’ result = 0
Ex :
Check the 3Ê³áµˆ bit of:n = |0|0|1|0|1|1|0|0|   (44)
                           7 6 5 4 3 2 1 0
Step 1: Create Mask
1 << 3 â†’ |0|0|0|0|1|0|0|0|

Step 2: AND Operation
      |0|0|1|0|1|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|0|0|1|0|0|0|
--> Observation : Result is non-zero â†’ 3Ê³áµˆ bit is ON

âŒ If Bit Was OFF
n = |0|0|1|0|0|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
---------------------
      |0|0|0|0|0|0|0|0|
ğŸ“Œ Result = 0 â†’ bit is OFF

Java Ex 1: 
int n = 44;   // 00101100
int i = 3;
boolean isON = (n & (1 << i)) != 0;
System.out.println(isON); // true

java Ex 2 : 
int n = 44;   // 00101100
int i = 3;

int checkMass = 1 << i ;

if((n & checkMass) == 0) {
System.out.println("isOFF");
}else{
System.out.println("isON");
}
// or
// boolean isOFF = (n & (1 << i)) == 0;
// System.out.println(isOFF); // false

Ex 3 : Real-Time Use Case (Permissions)
int READ  = 1 << 0;
int WRITE = 1 << 1;

int userPerm = READ | WRITE;
// check WRITE permission
if ((userPerm & WRITE) != 0) {
    System.out.println("Write allowed");
}

ğŸ§  Final Memory Rule : 
| Operation | Condition |
| --------- | --------- |
| Bit ON    | `!= 0`    |
| Bit OFF   | `== 0`    |


