üî¢ Bit Manipulation in Java (In-Depth Guide)
================================================
1Ô∏è‚É£ What is Bit Manipulation?
------------------------------------
--> Bit manipulation means working directly with binary bits (0s and 1s) of numbers using bitwise operators.
--> üëâ Computers store everything in binary
--> üëâ Operations at bit level are very fast
--> üëâ Used in:
           1. DSA problems
           2. Optimization
           3. Cryptography
           4. Low-level systems
           5. Competitive programming

2Ô∏è‚É£ Binary Representation Basics
--------------------------------
| Decimal | Binary |
| ------- | ------ |
| 0       | 0000   |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |

Example: int n = 5; // binary: 0101


3Ô∏è‚É£ Java Inbuilt Bit Utilities
---------------------------------
1. Integer.toBinaryString(n);
--> Converts an integer (decimal) into its binary string representation.
--> It returns a String, not a number.
Ex: 1
int n = 13;
System.out.println(Integer.toBinaryString(n));
Output : 1101

Ex: 2
   Scanner sc = new Scanner(System.in);
   System.out.print("Enter a decimal number: ");
   int n = sc.nextInt();
   String binary = Integer.toBinaryString(n);
   System.out.println("Binary: " + binary);

2. Integer.bitCount(n);
3. Integer.highestOneBit(n);
4. Integer.lowestOneBit(n);

1Ô∏è‚É£ Convert Decimal to Binary (Interview Explanation)
--> To convert a decimal number to binary:
     1. Divide the number by 2
     2. Store the remainder
     3. Repeat until number becomes 0
     4. Read remainders in reverse order

Example: Decimal = 13
13 √∑ 2 = 6  ‚Üí rem 1
6  √∑ 2 = 3  ‚Üí rem 0
3  √∑ 2 = 1  ‚Üí rem 1
1  √∑ 2 = 0  ‚Üí rem 1
Binary = 1101

Q: convert Decimal to binary Using While Loop (Most Asked in Interview)?
Ex: 
import java.util.Scanner;
public class DecimalToBinary {
    public static String decimalToBinary(int n) {

        // Edge case: if user enters 0
        if (n == 0) {
            return "0";
        }
   
        String binary = "";              // Empty string to store binary result
        
        while (n >= 1) {                // Loop until all binary digits are processed
            binary = (n % 2) + binary; // Get last binary digit
            n = n / 2;                 // Remove last binary digit
        }
        return binary;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a decimal number: ");
        int n = sc.nextInt();

        System.out.println("Binary: " + decimalToBinary(n));
        sc.close();
    }
}

Visual Table: 
| n  | n % 2 | binary | n / 2 |
| -- | ----- | ------ | ----- |
| 13 | 1     | "1"    | 6     |
| 6  | 0     | "01"   | 3     |
| 3  | 1     | "101"  | 1     |
| 1  | 1     | "1101" | 0     |
--> ‚ÄúExtract the last binary digit using % 2, store it, and remove it using / 2 until number becomes zero.‚Äù

2Ô∏è‚É£ Binary to Decimal (Reverse of Decimal ‚Üí Binary)
--> To convert binary(1101) ‚Üí decimal(13) :
    1. Read binary digits from right to left
    2. Multiply each bit with power of 2
    3. Add all values
Formula: decimal = digit √ó 2‚Å∞ + digit √ó 2¬π + digit √ó 2¬≤ + ...

üß† Example : Binary: 1101
1 √ó 2¬≥ = 8
1 √ó 2¬≤ = 4
0 √ó 2¬π = 0
1 √ó 2‚Å∞ = 1
----------------
Decimal = 13

package com.userService;
import java.util.Scanner;
public class Practice {

    static int convertBinaryToDecimal(String b) {      // Takes binary number as String and Returns decimal number as int
        int decimal = 0;  // stores final answer
        int powerOf2 = 1; // This represents 2‚Å∞ = 1, 2¬π = 2,2¬≤ = 4,2¬≥ = 8 the value of the rightmost bit
 
        for (int i = b.length() - 1; i >= 0; i--) { // Binary calculation starts from RIGHT to LEFT & Rightmost digit = lowest power (2‚Å∞)
            if (b.charAt(i) == '1') {              // 1. '1' √ó powerOf2 = value ‚Üí add it  2. '0' √ó powerOf2 = 0 ‚Üí no effect
                decimal = decimal + powerOf2;     // If digit is '1', add its weight to decimal.
            }
            powerOf2 = powerOf2 * 2;              // Move to Next Power of 2 like this : 1 ‚Üí 2 ‚Üí 4 ‚Üí 8 ‚Üí 16 ...
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the Binary number: ");
        String b = scan.next();   
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        scan.close();
    }
}
Table : Dry Run Example (Binary = 1101)
| Digit | powerOf2 | decimal |
| ----- | -------- | ------- |
| 1     | 1        | 1       |
| 0     | 2        | 1       |
| 1     | 4        | 5       |
| 1     | 8        | 13      |
--> ‚ÄúI traverse the binary string from right to left, multiply each bit with the corresponding power of 2, and add it to the decimal result.‚Äù

second Approach : most Efficient approach 
---------------
import java.util.Scanner;
public class BinaryToDecimal {
    static int convertBinaryToDecimal(String b) {          // used String because binary digits are characters ('0' and '1').
        int decimal = 0;

        for (int i = 0; i < b.length(); i++) {             // Binary: 1101 , Index : 0 1 2 3

            decimal = decimal * 2 + (b.charAt(i) - '0');  // decimal = decimal * 2 + digit;
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the Binary number: ");
        String b = sc.next();   // Example input: 1101
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        sc.close();
    }
}
FULL DRY RUN (Binary = "1101")
| i | b.charAt(i) | decimal * 2 | digit | new decimal |
| - | ----------- | ----------- | ----- | ----------- |
| 0 | '1'         | 0 √ó 2 = 0   | 1     | 1           |
| 1 | '1'         | 1 √ó 2 = 2   | 1     | 3           |
| 2 | '0'         | 3 √ó 2 = 6   | 0     | 6           |
| 3 | '1'         | 6 √ó 2 = 12  | 1     | 13          |


üîπ Part 1: decimal * 2
--> üëâ Binary is base-2
--> Multiplying by 2 means:
      1. Shift previous value left by 1 bit
      2. Prepare space for the next digit

üîπ Part 2: (b.charAt(i) - '0')
Suppose : b.charAt(i) == '1'
Then:
'1' - '0' = 1
'0' - '0' = 0
üëâ Converts character to number

Part 3: Add them
decimal = decimal * 2 + digit;
üëâ This adds the current binary digit to decimal value.

Q: How are Negative Numbers Stored in Binary?
=============================================
--> Computers store negative numbers using Two‚Äôs Complement representation.

Step-by-Step: Two‚Äôs Complement Method
--------------------------------------
Rule : To store ‚àíN in binary:
1Ô∏è‚É£ Write binary of +N
2Ô∏è‚É£ Take 1‚Äôs complement (invert bits)
3Ô∏è‚É£ Add 1

Example 1: Store ‚àí5 in 8-bit Binary
Step 1: Binary of +5
5  = 00000101

Step 2: 1‚Äôs Complement (invert bits)
00000101
--------
11111010

Step 3: Add 1
11111010
+       1
---------
11111011
--> ‚úÖ ‚àí5 = 11111011 (in 8-bit two‚Äôs complement)

Q: How to Identify a Negative Number?
--> üëâ MSB (Most Significant Bit)
| MSB | Meaning         |
| --- | --------------- |
| 0   | Positive number |
| 1   | Negative number |
Ex: 
1. Positive Number (+5) : 
00000101
‚Üë
MSB = 0 ‚Üí Positive

2. Negative Number (‚àí5)
11111011
‚Üë
MSB = 1 ‚Üí Negative

Q: How to Convert Back (Binary ‚Üí Decimal)?
If MSB = 1 (negative):
    1Ô∏è‚É£ Take 1‚Äôs complement
    2Ô∏è‚É£ Add 1
    3Ô∏è‚É£ Put negative sign
Example:
11111011
‚Üì invert
00000100
‚Üì +1
00000101 = 5

Q. Range of Values (Very Important)
--> For n bits:
--> Range = -2^(n-1)  to  +2^(n-1) - 1
--> Example: 8-bit
--> -128  to  +127

üîπ Bitwise Operators in Java 
====================================
| Operator             | Symbol | Meaning                 |                   |
| -------------------- | ------ | ----------------------- | ----------------- |
| AND                  | `&`    | 1 if both bits are 1    |                   |
| OR                   | `      | `                       | 1 if any bit is 1 |
| XOR                  | `^`    | 1 if bits are different |                   |
| NOT                  | `~`    | Inverts bits            |                   |
| Left Shift           | `<<`   | Multiply by 2           |                   |
| Right Shift          | `>>`   | Divide by 2             |                   |
| Unsigned Right Shift | `>>>`  | Fill with 0             |                   |

1Ô∏è‚É£ Bitwise AND (&) : Both bits must be 1
‚úÖ Truth Table
| A | B | A & B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |
Ex: 
int a = 5;   // 0101
int b = 3;   // 0011
System.out.println(a & b); // 1

üß† Logic: 
  0101
& 0011
------
  0001  ‚Üí 1
--> Used in: 1.Security  2.Role-based access  3.Feature toggles

2Ô∏è‚É£ Bitwise OR (|) : Any bit is 1 ‚Üí result 1
‚úÖ Truth Table
| A | B | A | B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 1     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a | b); // 7

üß† Logic:
  0101
| 0011
------
  0111 ‚Üí 7

üî• Real-Time Use : ‚úî Enable Features
int DARK_MODE = 1;
int NOTIFICATIONS = 2;
int settings = DARK_MODE | NOTIFICATIONS;

--> Used in: 1.Configuration flags   2.Logging levels   3.System properties

3Ô∏è‚É£ Bitwise XOR (^) : Different bits ‚Üí 1 (Both Same ‚Üí 0 , Both Different ‚Üí 1)
‚úÖ Truth Table
| A | B | A ^ B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 0     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a ^ b); // 6

üß† Logic:
  0101
^ 0011
------
  0110 ‚Üí 6

üî• Real-Time Use : 
1. ‚úî Swap Two Numbers (No Temp Variable)
int a = 10, b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;

2. ‚úî Find Unique Element : Very common in DSA interviews
int[] arr = {2, 3, 2, 4, 4};
int res = 0;

for (int x : arr)
    res ^= x;
System.out.println(res); // 3

4Ô∏è‚É£ Bitwise NOT (~)
‚úÖ Truth Table
| A | ~A |
| - | -- |
| 0 | 1  |
| 1 | 0  |
Ex: 
int a = 5;
System.out.println(~a);

 5  = 00000000 00000000 00000000 00000101
~5 = 11111111 11111111 11111111 11111010 ‚Üí -6

üß† Logic : ~n = -(n + 1)  // formula to calculate directly

Real-Time Use : 1.Bit masking  2.Clearing flags  3.Low-level operations
Ex : int mask = ~READ;

5Ô∏è‚É£ Left Shift (<<) : 
Ex : 
int a = 5;
System.out.println(a << 1); // 10

5 = 00000101
<<1
---------
10 = 00001010

üß† Logic : a << n = a √ó 2‚Åø

üî• Real-Time Use : 1.Fast multiplication  2.Hashing  3.Bitmap indexing
Ex: int size = 1 << 10; // 1024

6Ô∏è‚É£ Right Shift (>>) (Signed) : 1.Preserves sign bit  2.Fills with MSB
Ex: 
int a = -8;
System.out.println(a >> 1); // -4

-8 = 11111000
>>1
-----
-4 = 11111100

üî• Real-Time Use : 1.Division by 2   2.Arithmetic operations
Ex: int mid = (low + high) >> 1;
--> Used in Binary Search

7Ô∏è‚É£ Unsigned Right Shift (>>>) : 1.Always fills with 0   2.Ignores sign
Ex: 
int a = -8;
System.out.println(a >>> 1);

11111000 >>> 1
= 01111100 ‚Üí large positive number

üî• Real-Time Use : 1.Hash functions  2.Binary data parsing  3.Cryptography
Ex: int hash = value >>> 16;

Interview Summary (Must Remember) : 
| Operator | Key Point       |           |
| -------- | --------------- | --------- |
| `&`      | Check flags     |           |
| `        | `               | Set flags |
| `^`      | Toggle / unique |           |
| `~`      | Invert bits     |           |
| `<<`     | Fast multiply   |           |
| `>>`     | Signed divide   |           |
| `>>>`    | Unsigned shift  |           |






