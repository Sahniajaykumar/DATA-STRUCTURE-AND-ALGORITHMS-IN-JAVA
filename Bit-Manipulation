üî¢ Bit Manipulation in Java (In-Depth Guide)
================================================
Q: Bit : Bits are values in the form of 0 and 1 (binary form).

üîπ Bits in Java (Interview Point)
| Data Type | Size (Bytes)  | Size (Bits)   | Range (Numeric Form)                                        |
| --------- | ------------- | ------------- | ----------------------------------------------------------- |
| `byte`    | 1 byte        | 8 bits        |   ‚àí128 to 127                                               |
| `short`   | 2 bytes       | 16 bits       |   ‚àí32,768 to 32,767                                         |
| `int`     | 4 bytes       | 32 bits       |   ‚àí2,147,483,648 to 2,147,483,647                           |
| `long`    | 8 bytes       | 64 bits       |   ‚àí9,223,372,036,854,775,808 to 9,223,372,036,854,775,807   |
| `char`    | 2 bytes       | 16 bits       |   0 to 65,535                                               |
| `boolean` | JVM dependent | JVM dependent |   true / false                                              |
| `float`   | 4 bytes       | 32 bits       |   ~1.4E‚àí45 to 3.4028235E38                                  |
| `double`  | 8 bytes       | 64 bits       |   ~4.9E‚àí324 to 1.7976931348623157E308                       |


üîπ Bit vs Byte (Very Important) 
| Bit           | Byte              |
| ------------- | ----------------- |
| Single 0 or 1 | Group of 8 bits   |
| Smallest unit | Basic memory unit |

1Ô∏è‚É£ What is Bit Manipulation?
------------------------------------
--> Bit manipulation means working directly with binary bits (0s and 1s) of numbers using bitwise operators.
--> üëâ Computers store everything in binary
--> üëâ Operations at bit level are very fast
--> üëâ Used in:
           1. DSA problems
           2. Optimization
           3. Cryptography
           4. Low-level systems
           5. Competitive programming

2Ô∏è‚É£ Binary Representation Basics
--------------------------------
| Decimal | Binary |
| ------- | ------ |
| 0       | 0000   |
| 1       | 0001   |
| 2       | 0010   |
| 3       | 0011   |
| 4       | 0100   |
| 5       | 0101   |

Example: int n = 5; // binary: 0101

3Ô∏è‚É£ Java Inbuilt Bit Utilities
---------------------------------
1. Integer.toBinaryString(n);
--> Converts an integer (decimal) into its binary string representation.
--> It returns a String, not a number.
Ex: 1
int n = 13;
System.out.println(Integer.toBinaryString(n));
Output : 1101

Ex: 2
   Scanner sc = new Scanner(System.in);
   System.out.print("Enter a decimal number: ");
   int n = sc.nextInt();
   String binary = Integer.toBinaryString(n);
   System.out.println("Binary: " + binary);

2. Integer.bitCount(n);
3. Integer.highestOneBit(n);
4. Integer.lowestOneBit(n);

1Ô∏è‚É£ Convert Decimal to Binary (Interview Explanation)
--> To convert a decimal number to binary:
     1. Divide the number by 2
     2. Store the remainder
     3. Repeat until number becomes 0
     4. Read remainders in reverse order

Example: Decimal = 13
13 √∑ 2 = 6  ‚Üí rem 1
6  √∑ 2 = 3  ‚Üí rem 0
3  √∑ 2 = 1  ‚Üí rem 1
1  √∑ 2 = 0  ‚Üí rem 1
Binary = 1101

Q: convert Decimal to binary Using While Loop (Most Asked in Interview)?
Ex: 
import java.util.Scanner;
public class DecimalToBinary {
    public static String decimalToBinary(int n) {

        // Edge case: if user enters 0
        if (n == 0) {
            return "0";
        }
   
        String binary = "";              // Empty string to store binary result
        
        while (n >= 1) {                // Loop until all binary digits are processed
            binary = (n % 2) + binary; // Get last binary digit
            n = n / 2;                 // Remove last binary digit
        }
        return binary;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a decimal number: ");
        int n = sc.nextInt();

        System.out.println("Binary: " + decimalToBinary(n));
        sc.close();
    }
}

Visual Table: 
| n  | n % 2 | binary | n / 2 |
| -- | ----- | ------ | ----- |
| 13 | 1     | "1"    | 6     |
| 6  | 0     | "01"   | 3     |
| 3  | 1     | "101"  | 1     |
| 1  | 1     | "1101" | 0     |
--> ‚ÄúExtract the last binary digit using % 2, store it, and remove it using / 2 until number becomes zero.‚Äù

2Ô∏è‚É£ Binary to Decimal (Reverse of Decimal ‚Üí Binary)
--> To convert binary(1101) ‚Üí decimal(13) :
    1. Read binary digits from right to left
    2. Multiply each bit with power of 2
    3. Add all values
Formula: decimal = digit √ó 2‚Å∞ + digit √ó 2¬π + digit √ó 2¬≤ + ...

üß† Example : Binary: 1101
1 √ó 2¬≥ = 8
1 √ó 2¬≤ = 4
0 √ó 2¬π = 0
1 √ó 2‚Å∞ = 1
----------------
Decimal = 13

package com.userService;
import java.util.Scanner;
public class Practice {

    static int convertBinaryToDecimal(String b) {      // Takes binary number as String and Returns decimal number as int
        int decimal = 0;  // stores final answer
        int powerOf2 = 1; // This represents 2‚Å∞ = 1, 2¬π = 2,2¬≤ = 4,2¬≥ = 8 the value of the rightmost bit
 
        for (int i = b.length() - 1; i >= 0; i--) { // Binary calculation starts from RIGHT to LEFT & Rightmost digit = lowest power (2‚Å∞)
            if (b.charAt(i) == '1') {              // 1. '1' √ó powerOf2 = value ‚Üí add it  2. '0' √ó powerOf2 = 0 ‚Üí no effect
                decimal = decimal + powerOf2;     // If digit is '1', add its weight to decimal.
            }
            powerOf2 = powerOf2 * 2;              // Move to Next Power of 2 like this : 1 ‚Üí 2 ‚Üí 4 ‚Üí 8 ‚Üí 16 ...
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the Binary number: ");
        String b = scan.next();   
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        scan.close();
    }
}
Table : Dry Run Example (Binary = 1101)
| Digit | powerOf2 | decimal |
| ----- | -------- | ------- |
| 1     | 1        | 1       |
| 0     | 2        | 1       |
| 1     | 4        | 5       |
| 1     | 8        | 13      |
--> ‚ÄúI traverse the binary string from right to left, multiply each bit with the corresponding power of 2, and add it to the decimal result.‚Äù

second Approach : most Efficient approach 
---------------
import java.util.Scanner;
public class BinaryToDecimal {
    static int convertBinaryToDecimal(String b) {          // used String because binary digits are characters ('0' and '1').
        int decimal = 0;

        for (int i = 0; i < b.length(); i++) {             // Binary: 1101 , Index : 0 1 2 3

            decimal = decimal * 2 + (b.charAt(i) - '0');  // decimal = decimal * 2 + digit;
        }
        return decimal;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the Binary number: ");
        String b = sc.next();   // Example input: 1101
        System.out.println("Decimal number is: " + convertBinaryToDecimal(b));
        sc.close();
    }
}
FULL DRY RUN (Binary = "1101")
| i | b.charAt(i) | decimal * 2 | digit | new decimal |
| - | ----------- | ----------- | ----- | ----------- |
| 0 | '1'         | 0 √ó 2 = 0   | 1     | 1           |
| 1 | '1'         | 1 √ó 2 = 2   | 1     | 3           |
| 2 | '0'         | 3 √ó 2 = 6   | 0     | 6           |
| 3 | '1'         | 6 √ó 2 = 12  | 1     | 13          |


üîπ Part 1: decimal * 2
--> üëâ Binary is base-2
--> Multiplying by 2 means:
      1. Shift previous value left by 1 bit
      2. Prepare space for the next digit

üîπ Part 2: (b.charAt(i) - '0')
Suppose : b.charAt(i) == '1'
Then:
'1' - '0' = 1
'0' - '0' = 0
üëâ Converts character to number

Part 3: Add them
decimal = decimal * 2 + digit;
üëâ This adds the current binary digit to decimal value.

Q: How are Negative Numbers Stored in Binary?
=============================================
--> Computers store negative numbers using Two‚Äôs Complement representation.

Step-by-Step: Two‚Äôs Complement Method
--------------------------------------
Rule : To store ‚àíN in binary:
1Ô∏è‚É£ Write binary of +N
2Ô∏è‚É£ Take 1‚Äôs complement (invert bits)
3Ô∏è‚É£ Add 1

Example 1: Store ‚àí5 in 8-bit Binary
Step 1: Binary of +5
5  = 00000101

Step 2: 1‚Äôs Complement (invert bits)
00000101
--------
11111010

Step 3: Add 1
11111010
+       1
---------
11111011
--> ‚úÖ ‚àí5 = 11111011 (in 8-bit two‚Äôs complement)

Q: How to Identify a Negative Number?
--> üëâ MSB (Most Significant Bit)
| MSB | Meaning         |
| --- | --------------- |
| 0   | Positive number |
| 1   | Negative number |
Ex: 
1. Positive Number (+5) : 
00000101
‚Üë
MSB = 0 ‚Üí Positive

2. Negative Number (‚àí5)
11111011
‚Üë
MSB = 1 ‚Üí Negative

Q: How to Convert Back (Binary ‚Üí Decimal)?
If MSB = 1 (negative):
    1Ô∏è‚É£ Take 1‚Äôs complement
    2Ô∏è‚É£ Add 1
    3Ô∏è‚É£ Put negative sign
Example:
11111011
‚Üì invert
00000100
‚Üì +1
00000101 = 5

Q. Range of Values (Very Important)
--> For n bits:
--> Range = -2^(n-1)  to  +2^(n-1) - 1
--> Example: 8-bit
--> -128  to  +127

üîπ Bitwise Operators in Java 
====================================
| Operator             | Symbol | Meaning                 |                   |
| -------------------- | ------ | ----------------------- | ----------------- |
| AND                  | `&`    | 1 if both bits are 1    |                   |
| OR                   | `      | `                       | 1 if any bit is 1 |
| XOR                  | `^`    | 1 if bits are different |                   |
| NOT                  | `~`    | Inverts bits            |                   |
| Left Shift           | `<<`   | Multiply by 2           |                   |
| Right Shift          | `>>`   | Divide by 2             |                   |
| Unsigned Right Shift | `>>>`  | Fill with 0             |                   |

1Ô∏è‚É£ Bitwise AND (&) : Both bits must be 1
‚úÖ Truth Table
| A | B | A & B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 0     |
| 1 | 0 | 0     |
| 1 | 1 | 1     |
Ex: 
int a = 5;   // 0101
int b = 3;   // 0011
System.out.println(a & b); // 1

üß† Logic: 
  0101
& 0011
------
  0001  ‚Üí 1
--> Used in: 1.Security  2.Role-based access  3.Feature toggles

2Ô∏è‚É£ Bitwise OR (|) : Any bit is 1 ‚Üí result 1
‚úÖ Truth Table
| A | B | A | B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 1     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a | b); // 7

üß† Logic:
  0101
| 0011
------
  0111 ‚Üí 7

üî• Real-Time Use : ‚úî Enable Features
int DARK_MODE = 1;
int NOTIFICATIONS = 2;
int settings = DARK_MODE | NOTIFICATIONS;

--> Used in: 1.Configuration flags   2.Logging levels   3.System properties

3Ô∏è‚É£ Bitwise XOR (^) : Different bits ‚Üí 1 (Both Same ‚Üí 0 , Both Different ‚Üí 1)
‚úÖ Truth Table
| A | B | A ^ B |
| - | - | ----- |
| 0 | 0 | 0     |
| 0 | 1 | 1     |
| 1 | 0 | 1     |
| 1 | 1 | 0     |
Ex: 
int a = 5; // 0101
int b = 3; // 0011
System.out.println(a ^ b); // 6

üß† Logic:
  0101
^ 0011
------
  0110 ‚Üí 6

üî• Real-Time Use : 
1. ‚úî Swap Two Numbers (No Temp Variable)
int a = 10, b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;

2. ‚úî Find Unique Element : Very common in DSA interviews
int[] arr = {2, 3, 2, 4, 4};
int res = 0;

for (int x : arr)
    res ^= x;
System.out.println(res); // 3

4Ô∏è‚É£ Bitwise NOT (~)
‚úÖ Truth Table
| A | ~A |
| - | -- |
| 0 | 1  |
| 1 | 0  |
Ex: 
int a = 5;
System.out.println(~a);

 5  = 00000000 00000000 00000000 00000101
~5 = 11111111 11111111 11111111 11111010 ‚Üí -6

üß† Logic : ~n = -(n + 1)  // formula to calculate directly

Real-Time Use : 1.Bit masking  2.Clearing flags  3.Low-level operations
Ex : int mask = ~READ;

5Ô∏è‚É£ Left Shift (<<) : 
Ex : 
int a = 5;
System.out.println(a << 1); // 10

5 = 00000101
<<1
---------
10 = 00001010

üß† Logic : a << n = a √ó 2‚Åø

üî• Real-Time Use : 1.Fast multiplication  2.Hashing  3.Bitmap indexing
Ex: int size = 1 << 10; // 1024

6Ô∏è‚É£ Right Shift (>>) (Signed) : 1.Preserves sign bit  2.Fills with MSB
Ex: 
int a = -8;
System.out.println(a >> 1); // -4

-8 = 11111000
>>1
-----
-4 = 11111100

üî• Real-Time Use : 1.Division by 2   2.Arithmetic operations
Ex: int mid = (low + high) >> 1;
--> Used in Binary Search

7Ô∏è‚É£ Unsigned Right Shift (>>>) : 1.Always fills with 0   2.Ignores sign
Ex: 
int a = -8;
System.out.println(a >>> 1);

11111000 >>> 1
= 01111100 ‚Üí large positive number

üî• Real-Time Use : 1.Hash functions  2.Binary data parsing  3.Cryptography
Ex: int hash = value >>> 16;

Interview Summary (Must Remember) : 
| Operator | Key Point       |           |
| -------- | --------------- | --------- |
| `&`      | Check flags     |           |
| `        | `               | Set flags |
| `^`      | Toggle / unique |           |
| `~`      | Invert bits     |           |
| `<<`     | Fast multiply   |           |
| `>>`     | Signed divide   |           |
| `>>>`    | Unsigned shift  |           |


Q: üîπ What is Bit Masking?
=============================
--> Bit masking is a technique that uses bitwise operators to manipulate individual bits of an integer 
    for efficient storage, fast computation, and flag management.

--> It is commonly used in:
     1.Permissions
     2.Feature flags
     3.Performance-critical systems
     4.Low-level optimizations

üîπ Why Do We Use Bit Masking?
--> Interview points:
    1.Saves memory (1 bit per state)
    2.Very fast (bitwise ops are O(1))
    3.Multiple states stored in one integer
    4.Cleaner than multiple booleans

üîπ Interview Master Summary (Cheat Sheet)
| Task             | Formula       |         |
| ---------------- | ------------- | ------- |
| Check bit        | `n & (1<<i)`  |         |
| Set bit          | `n            | (1<<i)` |
| Clear bit        | `n & ~(1<<i)` |         |
| Toggle bit       | `n ^ (1<<i)`  |         |
| Odd/Even         | `n & 1`       |         |
| Power of 2       | `n&(n-1)`     |         |
| Clear lowest bit | `n&(n-1)`     |         |
| Rightmost bit    | `n & -n`      |         |

‚úÖ Basic Rules : Bits behave like electric switches.
Rule 1 : 0 ‚Üí OFF
Rule 2 : 1 ‚Üí ON

Rule 1 : 0 ‚Üí OFF
     |0|0|1|0|0|1|0|0|
OR(|)|0|0|0|0|0|0|0|0|
     ------------------
     |0|0|1|0|0|1|0|0|
Observation: zero(0) has not effect on bits

Rule 2 : 1 ‚Üí ON
     |0|0|1|0|0|1|0|0|
OR(|)|1|1|1|1|1|1|1|1|
     ------------------
     |1|1|1|1|1|1|1|1|
Observation: All off bits are turned on if we perform OR(|) operation with 1

Q 1: How to Switch ON the i·µó ∞ Bit (Bit Masking) ?
--> üëâ To switch ON a bit, we use Bitwise OR ( | )
--> Formula (Must Remember) : n = n | (1 << i);

üß† How This Works (Logic)
--> (1 << i) creates a mask
--> That mask has only the i·µó ∞ bit ON
--> OR (|) with 1 ‚Üí bit becomes ON
--> Other bits remain unchanged

Example : Switch ON the 3rd bit of: n = |0|0|1|0|0|1|0|0|

Step 1: Create mask
mask = 1 << 3; shifting 1 at 3rd index position from right to the left , which turn ON the bit at index 3.
  index :   7 6 5 4 3 2 1 0   --> Java uses 0-based indexing for counting from the right (LSB)  . 
1 << 3  ‚Üí  |0|0|0|0|1|0|0|0|  --> Only the 3 ≥·µà bit is ON
Note: 
--> Although bits are written from left to right, bit indexing in Java is always counted from the rightmost (LSB), starting at 0.

Step 2: OR operation with two rule first check which bit should change and which bit unchange.                             
      |0|0|1|0|0|1|0|0|
OR(|) |0|0|0|0|1|0|0|0| --> mask: (1 << i) and 3rd index left shift <i<<3) 0 0 0      
 ------------------------------------------------------------------
      |0|0|1|0|1|1|0|0|
Observation : Only the 3rd bit is switched ON, all other bits remain same

Ex 1 : 
int n = 36;   // 00100100
int i = 3;   // 
int maskON = 1 << i
System.out.println(n | maskON); // 44 (00101100)

// or,
// n = n | (1 << i);
// System.out.println(n); // 44 (00101100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = 0;

// switch ON WRITE permission
userPerm = userPerm | WRITE;

Q 2: How to Switch OFF the i·µó ∞ Bit (Bit Masking) ?
--> üëâ To switch OFF a bit, we use Bitwise AND (&) with NOT (~)
--> Formula : n = n & ~(1 << i);

Q: How This Works (Logic)
1. (1 << i) : creates a mask with only the i·µó ∞ bit ON

2. ~(1 << i) : flips the mask ‚Üí i·µó ∞ bit becomes OFF, others ON

3. n & mask : 
  ‚Üí AND with 0 turns OFF that bit
  ‚Üí AND with 1 keeps other bits unchanged

Example : Switch OFF the 3 ≥·µà bit of: n = |0|0|1|0|1|1|0|0|
                                           7 6 5 4 3 2 1 0
Step 1: Create Mask : 
 1 << 3  ‚Üí  |0|0|0|0|1|0|0|0|

Step 2: Invert Mask :
 ~(1 << 3) ‚Üí |1|1|1|1|0|1|1|1|

Step 3: AND Operation : 
      |0|0|1|0|1|1|0|0|
AND(&)|1|1|1|1|0|1|1|1|
      ------------------
      |0|0|1|0|0|1|0|0|
--> Observation : Only the 3 ≥·µà bit is switched OFF, all other bits remain unchanged

Ex: 
int n = 44;   // 00101100
int i = 3;

int maskOFF = 1 << i;
int flips = ~(1 << i);
System.out.println(n & flips); // 36

//Or using formula
//n = n & ~(1 << i);
//System.out.println(n); // 36 (00100100)

Ex 2 : Real-Time Use Case (Permissions)
int READ  = 1 << 0; // 0001
int WRITE = 1 << 1; // 0010

int userPerm = READ | WRITE; // both ON

// switch OFF WRITE permission
userPerm = userPerm & ~WRITE;

Q 3 : How to Toggle the i·µó ∞ Bit (Bit Masking) ?
Q: What does TOGGLE mean : üëâ Toggle = flip the bit
0 ‚Üí 1  (OFF ‚Üí ON)
1 ‚Üí 0  (ON ‚Üí OFF)

üîπ Operator Used : Bitwise XOR (^)
Why XOR?
| Bit | XOR 0         | XOR 1    |
| --- | ------------- | -------- |
| 0   | 0 (no change) | 1 (flip) |
| 1   | 1 (no change) | 0 (flip) |
--> üëâ XOR with 1 toggles the bit
Formula : n = n ^ (1 << i);

Q: How This Works (Logic) ?
  1. (1 << i) ‚Üí creates a mask with only the i·µó ∞ bit ON
  2. XOR (^) with:
       (a). 1 ‚Üí flips the bit
       (b). 0 ‚Üí keeps the bit unchanged
Ex : 
Toggle the 3 ≥·µà bit of:n = |0|0|1|0|1|1|0|0|   (44)
                            7 6 5 4 3 2 1 0
Step 1: Create Mask
  1 << 3 ‚Üí |0|0|0|0|1|0|0|0|

Step 2: XOR Operation
      |0|0|1|0|1|1|0|0|
XOR(^)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|1|0|0|1|0|0|

Observation : The 3 ≥·µà bit changes from 1 ‚Üí 0, all other bits remain unchanged

Java Ex: 
int n = 44;   // 00101100
int i = 3;

int maskToggle = 1 << i;
System.out.println(n ^ maskToggle); // 36

// or using formula
// n = n ^ (1 << i);
// System.out.println(n); // 36 (00100100)

Toggle Again (Proof) : 
n = n ^ (1 << i);
System.out.println(n); // 44

Ex: Real-Time Use Case : 
int DARK_MODE = 1 << 2;
settings ^= DARK_MODE;

Q 3 : How to check the i·µó ∞ Bit (Bit Masking) ?
Q: What does CHECK mean? 
-->  We want to know whether the i·µó ∞ bit is 1 (ON) or 0 (OFF) .
-->  We do NOT change the number .

üîπ Operator Used : Bitwise AND (&)
Why AND?
  1. AND with 1 ‚Üí keeps bit value
  2. AND with 0 ‚Üí result becomes 0

üìå Formula : (n & (1 << i)) != 0

üß† How This Works (Logic)?
   1. (1 << i) creates a mask
     --> only the i·µó ∞ bit is ON

   2. AND (&) operation:
     --> If i·µó ∞ bit in n is 1 ‚Üí result ‚â† 0
     --> If i·µó ∞ bit in n is 0 ‚Üí result = 0
Ex :
Check the 3 ≥·µà bit of:n = |0|0|1|0|1|1|0|0|   (44)
                           7 6 5 4 3 2 1 0
Step 1: Create Mask
1 << 3 ‚Üí |0|0|0|0|1|0|0|0|

Step 2: AND Operation
      |0|0|1|0|1|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
      ------------------
      |0|0|0|0|1|0|0|0|
--> Observation : Result is non-zero ‚Üí 3 ≥·µà bit is ON

‚ùå If Bit Was OFF
n = |0|0|1|0|0|1|0|0|
AND(&)|0|0|0|0|1|0|0|0|
---------------------
      |0|0|0|0|0|0|0|0|
üìå Result = 0 ‚Üí bit is OFF

Java Ex 1: 
int n = 44;   // 00101100
int i = 3;
boolean isON = (n & (1 << i)) != 0;
System.out.println(isON); // true

java Ex 2 : 
int n = 44;   // 00101100
int i = 3;

int checkMass = 1 << i ;

if((n & checkMass) == 0) {
System.out.println("isOFF");
}else{
System.out.println("isON");
}
// or
// boolean isOFF = (n & (1 << i)) == 0;
// System.out.println(isOFF); // false

Ex 3 : Real-Time Use Case (Permissions)
int READ  = 1 << 0;
int WRITE = 1 << 1;

int userPerm = READ | WRITE;
// check WRITE permission
if ((userPerm & WRITE) != 0) {
    System.out.println("Write allowed");
}

üß† Final Memory Rule : 
| Operation | Condition |
| --------- | --------- |
| Bit ON    | `!= 0`    |
| Bit OFF   | `== 0`    |

Q: Find the Position of Rightmost Set Bit (Without Built-ins) ?
Ex 1 : 
import java.util.Scanner;
public class Bitwise {

    // Returns 1-based position of Right Most Set Bit
    static int positionOfRMSB(int n) {
        if (n == 0) {
            return -1; // no set bits
        }

        int pos = 1;
        while ((n & 1) == 0) {
            n >>= 1;
            pos++;
        }
        return pos;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        int pos = positionOfRMSB(n);
        if (pos == -1) {
            System.out.println("No set bits present");
        } else {
            System.out.println("Position of Rightmost Set Bit: " + pos);
        }
        scan.close();
    }
}

Ex 2 : Q: Find the Position of Rightmost Set Bit (With Built-ins) ? 
import java.util.Scanner;
public class Bitwise {

    // Returns 1-based position of Right Most Set Bit
    static int positionOfRMSB(int n) {
        if (n == 0) {
            return -1; // no set bit
        }
        return Integer.numberOfTrailingZeros(n) + 1;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        int pos = positionOfRMSB(n);
        if (pos == -1) {
            System.out.println("No set bits present");
        } else {
            System.out.println("Position of Rightmost Set Bit: " + pos);
        }
        scan.close();
    }
}

Q: Count the number of set bit in a given number using Brian Kernighan‚Äôs Algorithm ?
--> Idea : Each iteration removes the rightmost set bit.
--> Formula : n = n & (n - 1);
--> Example
       n = 44 ‚Üí 00101100
--> Steps:
      00101100  (44)
      00101000  (n & (n-1))
      00100000
      00000000
--> Set bits count = 3 ( three times removed 1 ) 
java Ex: 
import java.util.Scanner;
public class Bitwise {
    static int countSetBits(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1); // removes rightmost set bit
            count++;
        }
        return count;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        System.out.println("Number of set bits: " + countSetBits(n));
        scan.close();
    }
}

Q: Write a program to find whether a number is a power of 2 ? (Adobe Interview Question_PowerOf2) 
--> A number is a power of 2 if it has exactly one set bit in its binary representation.
--> Formula : n & (n - 1) // Brian Kernighan‚Äôs Algorithm
--> Clears the rightmost set bit
--> If the result becomes 0, the number had only one set bit

java Ex: 
import java.util.Scanner;
public class Bitwise {
    static boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scan.nextInt();

        if (isPowerOfTwo(n)) {
            System.out.println(n + " is a power of 2");
        } else {
            System.out.println(n + " is NOT a power of 2");
        }
        scan.close();
    }
}

üîπ Find the Lonely(unique) Integer (vvi)
Q: Given an array where every element appears twice except one, find the element that appears only once.
üß† Key Idea : XOR Properties
               a ^ a = 0
               a ^ 0 = a
üëâ When we XOR all elements:
               1. Pairs cancel out
               2. The unique (lonely) number remains
Most Efficient Approach (XOR) :  Time: O(n) and  Space: O(1)

java Ex: 
import java.util.Scanner;
public class LonelyInteger {
    static int findLonelyInteger(int[] arr) {
        int result = 0;

        for (int num : arr) {
            result ^= num;  // XOR operation
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();
        int[] arr = new int[n];

        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        System.out.println("Lonely Integer: " + findLonelyInteger(arr));
        scan.close();
    }
}

üîπ Lonely Integer when Others Appear 3 Times
Q: Given an array where every element appears exactly 3 times except one element which appears only once, find that unique (lonely) number.
Note: 
--> Now XOR Alone Won‚Äôt Work Here 
--> Q: ‚ùå Why XOR Alone Won‚Äôt Work Here?
    Because:
         a ^ a ^ a = a   ‚ùå (not 0)
--> So duplicates do NOT cancel out when they appear 3 times.

üß† Efficient Concept (Interview Explanation)
--> Count bits at each position (0‚Äì31)
--> If a bit count is not divisible by 3, that bit belongs to the lonely number
--> üëâ This works because:
          1. Triplets contribute multiples of 3
          2. Lonely number contributes extra bits
‚úÖ Optimal Approach (Bit Counting)
‚è±  Time: O(32 √ó n) ‚Üí O(n)
üß† Space: O(1)

java Ex : 
import java.util.Scanner;
public class LonelyIntegerThrice {

    static int findLonelyInteger(int[] arr) {
        int result = 0;

        // Check each bit position
        for (int bit = 0; bit < 32; bit++) {
            int count = 0;

            for (int num : arr) {
                if ((num & (1 << bit)) != 0) {
                    count++;
                }
            }
            // If count is not multiple of 3, set that bit
            if (count % 3 != 0) {
                result |= (1 << bit);
            }
        }
        return result;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        System.out.println("Lonely Integer: " + findLonelyInteger(arr));
        scan.close();
    }
}
Input : 
7
2 2 3 2 4 4 4

Explanation :
2 ‚Üí appears 3 times
4 ‚Üí appears 3 times
3 ‚Üí appears once ‚úÖ

Output : 
Lonely Integer: 3
Q: Can this handle negative numbers?
--> ‚úîÔ∏è YES, because Java uses two‚Äôs complement and we check all 32 bits.

üîπ Find the Two Lonely Integers : (All other numbers appear twice)
Q: Given an array where exactly two numbers appear once and all other numbers appear twice, find the two unique numbers.

üß† Key Idea (Interview Explanation)
1. XOR all numbers ‚Üí duplicates cancel out
   xor = a ^ b
--> (a and b are the two lonely numbers)

2. Find rightmost set bit in xor
   rmsb = xor & (-xor)

3. Divide numbers into two groups
     (I).  Group 1 ‚Üí bit set
     (II). Group 2 ‚Üí bit not set

4. XOR each group separately ‚Üí get a and b

‚úÖ Optimal Solution
Time: O(n)
Space: O(1)
--> No extra data structures

java Ex: 
import java.util.Scanner;
public class TwoLonelyIntegers {

    static void findTwoLonely(int[] arr) {
        int xor = 0;

        // Step 1: XOR all elements
        for (int num : arr) {
            xor ^= num;
        }

        // Step 2: Find rightmost set bit
        int rmsb = xor & (-xor);

        int num1 = 0, num2 = 0;

        // Step 3: Divide into two groups
        for (int num : arr) {
            if ((num & rmsb) != 0) {
                num1 ^= num;
            } else {
                num2 ^= num;
            }
        }
        System.out.println("Lonely numbers are: " + num1 + " and " + num2);
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter number of elements: ");
        int n = scan.nextInt();

        int[] arr = new int[n];

        System.out.println("Enter elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        findTwoLonely(arr);
        scan.close();
    }
}
Input
6
2 4 7 9 2 4

XOR Flow
xor = 7 ^ 9
rmsb = 2

Output
Lonely numbers are: 7 and 9

üîπ Find the Missing Number (Using XOR)
Q: Given an array containing n distinct numbers taken from the range 0 to n, find the missing number.

üß† Key Idea :
XOR Properties
a ^ a = 0
a ^ 0 = a

üëâ If we XOR:
    1.All numbers from 0 to n
    2.All numbers present in the array
‚û°Ô∏è All duplicates cancel out, leaving the missing number.

‚úÖ Optimal Approach
Time: O(n)
Space: O(1)
--> No extra memory

java Ex: 
import java.util.Scanner;
public class MissingNumber {

    static int findMissingNumber(int[] arr, int n) {
        int xor = 0;

        // XOR all numbers from 0 to n
        for (int i = 0; i <= n; i++) {
            xor ^= i;
        }

        // XOR all array elements
        for (int num : arr) {
            xor ^= num;
        }
        return xor;
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter n (range 0 to n): ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter array elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }

        System.out.println("Missing Number: " + findMissingNumber(arr, n));
        scan.close();
    }
}
Input
n = 5
Array = 0 1 3 4 5

XOR Flow
(0^1^2^3^4^5) ^ (0^1^3^4^5)
= 2

Output
Missing Number: 2

üîπ Find the Missing AND Repeating Number
Q: Given an array of size n containing numbers from 1 to n, one number is missing and one number is repeating.
Find both numbers.

üß† Key Idea : 
     1. XOR all array elements with numbers 1..n
     2. Result = missing ^ repeating
     3. Find rightmost set bit to separate them
     4. XOR in two groups to get both numbers
     5. Decide which is missing and which is repeating

‚úÖ  Optimal Solution
Time: O(n)
Space: O(1)
--> No extra memory

java Ex : 
import java.util.Scanner;
public class MissingRepeating {

    static void findMissingAndRepeating(int[] arr, int n) {
        int xor = 0;

        // Step 1: XOR array and numbers 1..n
        for (int i = 0; i < n; i++) {
            xor ^= arr[i];
            xor ^= (i + 1);
        }

        // Step 2: Rightmost set bit
        int rmsb = xor & (-xor);

        int x = 0, y = 0;

        // Step 3: Divide into two groups
        for (int i = 0; i < n; i++) {
            if ((arr[i] & rmsb) != 0)
                x ^= arr[i];
            else
                y ^= arr[i];

            if (((i + 1) & rmsb) != 0)
                x ^= (i + 1);
            else
                y ^= (i + 1);
        }

        // Step 4: Identify which is missing/repeating
        int repeating = 0, missing = 0;
        for (int num : arr) {
            if (num == x) {
                repeating = x;
                missing = y;
                break;
            } else if (num == y) {
                repeating = y;
                missing = x;
                break;
            }
        }

        System.out.println("Repeating Number: " + repeating);
        System.out.println("Missing Number: " + missing);
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter n: ");
        int n = scan.nextInt();

        int[] arr = new int[n];
        System.out.println("Enter array elements:");
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }

        findMissingAndRepeating(arr, n);
        scan.close();
    }
}
Input
n = 5
Array = 1 2 2 4 5

Output
Repeating Number: 2
Missing Number: 3

Q 1: Write a program to Swap Two Numbers Using XOR ?
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter first number: ");
        int a = sc.nextInt();

        System.out.print("Enter second number: ");
        int b = sc.nextInt();

        // XOR swap
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;

        System.out.println("After Swapping:");
        System.out.println("First number: " + a);
        System.out.println("Second number: " + b);
    }
}
Enter first number: 10
Enter second number: 20
After Swapping:
First number: 20
Second number: 10

Q 2: Swap Two Numbers Using Array + XOR
import java.util.Scanner;
public class SwapUsingArray {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Create array of size 2
        int[] arr = new int[2];

        System.out.print("Enter first number: ");
        arr[0] = sc.nextInt();

        System.out.print("Enter second number: ");
        arr[1] = sc.nextInt();

        // XOR Swap
        arr[0] = arr[0] ^ arr[1];
        arr[1] = arr[0] ^ arr[1];
        arr[0] = arr[0] ^ arr[1];

        System.out.println("After Swapping:");
        System.out.println("First number: " + arr[0]);
        System.out.println("Second number: " + arr[1]);
        sc.close();
    }
}
--> We store both numbers in an array ‚Üí arr[0] and arr[1].
--> We use XOR swap to exchange their values without a temporary variable.
Enter first number: 15
Enter second number: 25
After Swapping:
First number: 25
Second number: 15

Q 3 : Swap Any Two Indices in Array (XOR + Method + Scanner)
import java.util.Scanner;
public class SwapAnyIndices {

    // Method to swap elements at indices i and j using XOR
    static void swap(int[] arr, int i, int j) {
        if (i == j) return; // swapping same index does nothing
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter size of array: ");
        int n = sc.nextInt();

        int[] arr = new int[n];

        System.out.println("Enter array elements:");
        for (int k = 0; k < n; k++) {
            arr[k] = sc.nextInt();
        }

        System.out.print("Enter first index to swap (0-based): ");
        int i = sc.nextInt();

        System.out.print("Enter second index to swap (0-based): ");
        int j = sc.nextInt();

        // Swap using method
        swap(arr, i, j);

        System.out.println("Array after swapping:");
        for (int x : arr) {
            System.out.print(x + " ");
        }
        sc.close();
    }
}
Enter size of array: 5
Enter array elements:
10 20 30 40 50
Enter first index to swap (0-based): 1
Enter second index to swap (0-based): 3
Array after swapping:
10 40 30 20 50

Q 4 : Swap Any Two Indices Using Temp Variable
import java.util.Scanner;
public class SwapUsingTemp {

    // Method to swap two elements using a temporary variable
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();          // size of array
        int[] arr = new int[n];

        for (int k = 0; k < n; k++)
            arr[k] = sc.nextInt();     // array elements

        int i = sc.nextInt();          // first index to swap
        int j = sc.nextInt();          // second index to swap

        swap(arr, i, j);

        for (int x : arr)
            System.out.print(x + " "); // output array
        sc.close();
    }
}
Input:
5
10 20 30 40 50
1 3

Output:
10 40 30 20 50

Q 5 : Swap Two number Using Temp Variable
import java.util.Scanner;
public class SwapUsingMethod {

    // Method to swap first two elements using a temporary variable
    static void swapFirstTwo(int[] arr) {
        int temp = arr[0];
        arr[0] = arr[1];
        arr[1] = temp;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int[] arr = new int[2];

        System.out.print("Enter first number: ");
        arr[0] = sc.nextInt();

        System.out.print("Enter second number: ");
        arr[1] = sc.nextInt();

        System.out.println("Before Swapping:");
        System.out.println("First number: " + arr[0]);
        System.out.println("Second number: " + arr[1]);

        // Call the swap method
        swapFirstTwo(arr);

        System.out.println("After Swapping:");
        System.out.println("First number: " + arr[0]);
        System.out.println("Second number: " + arr[1]);

        sc.close();
    }
}

üß† Following Major Problem Categories using bitwise operatore (Interview View)
==============================================================================
1Ô∏è‚É£ Bit Basics (10‚Äì15 problems)
1.Check odd / even
2.Set, clear, toggle, check i·µó ∞ bit
3.Rightmost / leftmost set bit
4.Power of 2 / 4
5.Count trailing zeros

2Ô∏è‚É£ XOR-Based Problems (15‚Äì20 problems)
1.Lonely integer (once)
2.Lonely integer (twice)
3.Missing number
4.Missing + repeating
5.Swap numbers without temp
6.Find duplicate
7.XOR of range

3Ô∏è‚É£ Counting Bits (10‚Äì15 problems)
1.Count set bits
2.Brian Kernighan‚Äôs algorithm
3.Count bits from 1 to N
4.Parity of number

4Ô∏è‚É£ Subsets & Masks (10‚Äì15 problems)
1.Generate all subsets
2.Permission systems
3.Feature flags
4.Power set problems

5Ô∏è‚É£ Math + Bit Tricks (10‚Äì15 problems)
1.Multiply/divide by 2
2.Fast exponentiation
3.Modulo using bitwise
4.Gray code

6Ô∏è‚É£ Advanced / Competitive (15‚Äì25 problems)
1.Single number II / III
2.Bit DP
3.Trie + XOR max
4.AND / OR subarray problems













