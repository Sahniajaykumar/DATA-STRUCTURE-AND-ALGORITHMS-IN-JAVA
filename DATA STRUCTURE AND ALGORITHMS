ğŸ”¹ What is a Data Structure?
--> A data structure defines:
        1. How data is stored in memory
        2. How data can be accessed and modified
        3. The performance of operations (time & space complexity)

ğŸ”¹ Types of Data Structures in Java :
          
1ï¸âƒ£ Primitive Data Structures :  Store single values.
 int, float, double, char, boolean

2ï¸âƒ£ Non-Primitive (Reference) Data Structures : 

ğŸ”¸ A. Linear Data Structures : Data stored sequentially.

1. Array : 
  Fixed size
  Same data type
  int[] arr = {1, 2, 3, 4};
  Used when: Size is known and fast access is required

2. Linked List
Dynamic size
Elements connected using pointers

LinkedList<Integer> list = new LinkedList<>();
list.add(10);
list.add(20);

Used when: Frequent insertion/deletion

3. Stack (LIFO)
Last In First Out

Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.pop();

Used when: Undo/Redo, function calls

4. Queue (FIFO)

First In First Out

Queue<Integer> queue = new LinkedList<>();
queue.add(10);
queue.poll();

Used when: Task scheduling, buffering

ğŸ”¸ B. Non-Linear Data Structures
--------------------------------------
Data stored hierarchically or graph-like.

1. Tree

Parent-child relationship

// Example: Binary Tree
class Node {
    int data;
    Node left, right;
}

Used when: Hierarchical data (File system)

2. Graph

Nodes connected by edges

Map<Integer, List<Integer>> graph = new HashMap<>();


Used when: Social networks, maps

ğŸ”¸ C. Hash-Based Data Structures
----------------------------------------
Fast access using key-value pairs.

1. HashMap : 
Map<Integer, String> map = new HashMap<>();
map.put(1, "Ajay");

O(1) average time complexity
Allows one null key

2. HashSet : 
Set<Integer> set = new HashSet<>();
No duplicates
Unordered

  ğŸ”¹ Java Collection Framework (Important for Interviews)

| Interface | Implementations           |
| --------- | ------------------------- |
| List      | ArrayList, LinkedList     |
| Set       | HashSet, TreeSet          |
| Queue     | PriorityQueue, ArrayDeque |
| Map       | HashMap, TreeMap          |


  ğŸ”¹ Time Complexity Overview

| Data Structure | Access | Insert | Delete |
| -------------- | ------ | ------ | ------ |
| Array          | O(1)   | O(n)   | O(n)   |
| LinkedList     | O(n)   | O(1)   | O(1)   |
| Stack          | O(1)   | O(1)   | O(1)   |
| Queue          | O(1)   | O(1)   | O(1)   |
| HashMap        | O(1)*  | O(1)*  | O(1)*  |


ğŸ”¹ Why Data Structures Matter (Interview Answer)
   --> Data structures help in writing efficient, optimized, and scalable applications by reducing time and memory usage.
  

ğŸ§  PHASE 1: ARRAYS & STRINGS (MOST ASKED)

1ï¸âƒ£ ARRAY â€” INTERVIEW CORE
ğŸ”¹ Interview Questions :  âœ… 1. Traversal Algorithm , âœ… 2. Insertion (at index k) Algorithm âœ… 3. Deletion Algorithm âœ… 4. Searching(Linear Search , Binary Search (Sorted Array))

âœ” Reverse an array
âœ” Find max / min
âœ” Remove duplicates
âœ” Two Sum
âœ” Rotate array
âœ” Find missing number

ğŸ§  PHASE 2: LINKED LIST (FAVORITE FOR LOGIC)
2ï¸âƒ£ LINKED LIST QUESTIONS : âœ… 1. Insertion at Beginning , âœ… 2. Insertion at End, âœ… 3. Deletion, âœ… 4. Traversal

âœ” Reverse linked list
âœ” Detect cycle
âœ” Find middle
âœ” Merge two sorted lists


ğŸ§  PHASE 3: STACK & QUEUE
3ï¸âƒ£ STACK QUESTIONS : 1 âœ… PUSH . 2 âœ… POP
  
âœ” Valid parentheses
âœ” Reverse string
âœ” Next greater element

4ï¸âƒ£ QUEUE QUESTIONS
âœ… ENQUEUE , âœ… DEQUEUE
  
âœ” Implement stack using queue
âœ” Sliding window maximum

ğŸ§  PHASE 4: HASHING (VERY IMPORTANT)
5ï¸âƒ£ HASHMAP / HASHSET

âœ” Frequency count , Insert , Search
âœ” First non-repeating element
âœ” Detect duplicates

ğŸ§  PHASE 5: TREES & BST (ADVANCED ROUND)
6ï¸âƒ£ BINARY TREE
âœ… Inorder (LNR) , âœ… Preorder (NLR) , âœ… Postorder (LRN)
  
âœ” Traversals
âœ” Height
âœ” Diameter

7ï¸âƒ£ BST SEARCH
  
  ğŸ”¹ Property
       Left < Root < Right
ğŸ”¹ BST Search Algorithm

ğŸ§  PHASE 6: SORTING & SEARCHING
8ï¸âƒ£ QUICK SORT (INTERVIEW FAVORITE) , ğŸ”¹ Bubble Sort , ğŸ”¹ Selection Sort , ğŸ”¹ Insertion Sort

ğŸ§  PHASE 7: GRAPHS (PRODUCT COMPANIES)
9ï¸âƒ£ GRAPH (BFS & DFS)
ğŸ”¹ BFS Algorithm , ğŸ”¹ DFS Algorithm

ğŸ§ª HOW TO ANSWER IN INTERVIEW (IMPORTANT)
Always follow:

Brute force approach

Optimized approach

Complexity analysis

Edge cases
