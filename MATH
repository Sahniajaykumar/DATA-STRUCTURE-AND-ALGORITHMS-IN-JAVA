Count the number of digits in a Number 
--------------------------------------

Q: How to count the number of  digits in a Number? 

Algorithms : 
     1. checks if digits exist.
     2. Remove the last digit(devided by 10)
     3. Increase value of count by 1(one)
     4. Repeate step 1 to step 3 till digit remains

Example : 
package com.practice;
import java.util.Scanner;

public class CountDigits {
    public static int countDigits(int n) {

        int count = 0;

        // Handle case when number is 0
        if (n == 0) {
            return 1;
        }
        // Convert negative number to positive manually
        if (n < 0) {
            n = -n;
        }

        // Count digits
        while (n > 0) {
            n = n / 10;   // remove last digit
            count++;      // increase count
        }

        return count;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the number: ");
        int n = scan.nextInt();

        int result = countDigits(n);
        System.out.println("Number of digits: " + result);
    }
}

-------------------
Factorial
--------------------
Q: Write a Java program to find the factorial of a given number without using any inbuilt functions.

Example : Iterative approach 

package com.practice;

import java.util.Scanner;

public class Factorial {

    public static long factorial(int n) {

        if (n < 0) {
            return -1; // factorial not defined
        }

        long res = 1;

        for (int i = 1; i <= n; i++) {
            res = res * i;
        }

        return res;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the number for factorial: ");
        int n = scan.nextInt();

        long result = factorial(n);

        if (result == -1) {
            System.out.println("Factorial is not defined for negative numbers.");
        } else {
            System.out.println("Factorial of " + n + " is: " + result);
        }
    }
}

Note :
Q1Ô∏è‚É£ What is factorial?

üëâ Factorial of a number n is the product of all positive integers from 1 to n.

Q2Ô∏è‚É£ What is the factorial of 0?

üëâ 0! = 1

Q3Ô∏è‚É£ Why do we start result as 1?

üëâ Because factorial involves multiplication, and 1 is the identity for multiplication.

Q4Ô∏è‚É£ Can factorial be calculated for negative numbers?

üëâ No, factorial is not defined for negative numbers.

Q5Ô∏è‚É£ Why did you use long instead of int?

üëâ Because factorial values grow very fast and int overflows after 12!.

Q6Ô∏è‚É£ What is the difference between iterative and recursive factorial?

üëâ Iterative uses loops, recursion uses function calls. Iterative is more memory-efficient.

-----------------------
Trailing zeros : 
------------------
Q: üëâ ‚ÄúWrite a Java program to find the number of trailing zeroes in the factorial of a given number using an efficient algorithm.‚Äù

Example : 

package com.practice;

import java.util.Scanner;

public class TrailingZeros {

    static int trailingZeros(int n) {

        if (n < 0) {
            return -1; // not defined
        }

        int res = 0;
        int powerOf5 = 5;

        while (n >= powerOf5) {
            res = res + (n / powerOf5);
            powerOf5 = powerOf5 * 5;
        }

        return res;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the number: ");
        int n = scan.nextInt();

        int result = trailingZeros(n);

        if (result == -1) {
            System.out.println("Trailing zeroes not defined for negative numbers.");
        } else {
            System.out.println("Trailing zeroes in " + n + "! = " + result);
        }
    }
}

Note : ‚ÄúTrailing zeroes in factorial depend on the number of factors of 5, so I sum n divided by powers of 5.‚Äù

Q: Why not count 2s?
A: Because factors of 2 are always more than factors of 5 in factorials.

===========================================GCD/HCF==========================================================================
Three way solve : 
1. Bruteforce Algorithm :
------------------------
a. Find the minimum of both A & B 
b. Use for loop and start from  `i = m` and go till one 
c. Inside the loop , check if  `i` is a common divisor .
d. If `i` is a common divisor , return `i` .

Example : 
package com.practice;
import java.util.Scanner;
public class BruteForceGCD {
    public static int bruteForceGCD(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negative numbers to positive (without inbuilt functions)
        if (a < 0) {
            a = -a;
        }
        if (b < 0) {
            b = -b;
        }

        // Find minimum manually
        int min;
        if (a < b) {
            min = a;
        } else {
            min = b;
        }

        // Brute-force GCD logic
        for (int i = min; i >= 1; i--) {
            if (a % i == 0 && b % i == 0) {
                return i;
            }
        }
        return 1;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int result = bruteForceGCD(a, b);
        System.out.println("GCD is: " + result);
        scan.close();
    }
}

2. Euclid's Algorithm : Efficient approach than brutforce algorithm
a. Find the larger number 
b. Replace the larger number by the difference between the larger and smaller number 
c. Repeat step `a` and `b` until both number become equal .

Example : 
package com.practice;
import java.util.Scanner;

public class EuclidAlgorithmGCD {
    public static int euclidAlgorithmGcd(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negatives to positive (no inbuilt functions)
        if (a < 0) a = -a;
        if (b < 0) b = -b;

        // Euclidean Algorithm using subtraction
        while (a != b) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
        return a; // or b (both are same)
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int res = euclidAlgorithmGcd(a, b);
        System.out.println("GCD is: " + res);
        scan.close();
    }
}

3. Most Optimised Euclid's Algorithm : given by GABRIEL LAME .

üìå Algorithm: GCD Using Euclidean Algorithm (Modulo Method) , // logrithimc time complexity
Step 1: Read two integers a and b.
Step 2: If a is equal to 0, return b as the GCD.
Step 3: If b is equal to 0, return a as the GCD.
Step 4: If a is negative, convert it to positive.
Step 5: If b is negative, convert it to positive.
Step 6: Repeat the following steps while both a and b are not equal to 0:
  --> If a is greater than b, replace a with a % b.
  --> Otherwise, replace b with b % a.
Step 7: When the loop ends, one of the numbers becomes 0.
Step 8: If a is not equal to 0, return a as the GCD; otherwise, return b.

package com.practice;
import java.util.Scanner;

public class EuclidAlgorithmGCD {

    public static int euclidAlgorithmGcd(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negatives to positive (no inbuilt functions)
        if (a < 0) a = -a;
        if (b < 0) b = -b;

        // Euclidean Algorithm using modulo(%)                                Most Efficient approach 
        while (a != 0 && b !=0) {
            if (a > b) {
                a = a % b;
            } else {
                b = b % a;
            }
        }
        if(a !=0){
            return a;
        }else{
            return b;
        }
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int res = euclidAlgorithmGcd(a, b);
        System.out.println("GCD is: " + res);
        scan.close();
    }
}
--------------------------------------------------------------------------------------------------------------------
üìå What is LCM?
--> LCM (Least Common Multiple) of two numbers is the smallest positive number that is divisible by both numbers.

üîπ Key Interview Formula (VERY IMPORTANT)
   -------------------------------
  |  LCM(a*b) = |a*b| / GCD(a,b) |
  --------------------------------
--> üëâ This is the most efficient and expected approach in interviews.

üß† Step-by-Step Algorithm (Using GCD) : 

Step 1: Read two integers a and b.
Step 2: If either a or b is 0, return 0 as LCM.
Step 3: Convert negative numbers to positive.
Step 4: Find GCD(a, b) using Euclidean Algorithm.
Step 5: Compute
LCM = (a * b) / GCD
Step 6: Return the LCM.

Example : 
package com.practice;
import java.util.Scanner;

public class LCMUsingGCD {

    // GCD using Euclidean Algorithm
    public static int gcd(int a, int b) {

        if (a == 0) return b;
        if (b == 0) return a;

        if (a < 0) a = -a;
        if (b < 0) b = -b;

        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    // LCM method
    public static int lcm(int a, int b) {
        if (a == 0 || b == 0) {
            return 0;
        }
        int gcdValue = gcd(a, b);
        return (a * b) / gcdValue;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter first number:");
        int a = scan.nextInt();

        System.out.println("Enter second number:");
        int b = scan.nextInt();

        int result = lcm(a, b);
        System.out.println("LCM is: " + result);
        scan.close();
    }
}

====================
Problems on prime
====================

1Ô∏è‚É£ What are Prime Numbers?
--> A prime number:
      1. Greater than 1
      2. Has exactly two factors ‚Üí 1 and itself

Examples : 2, 3, 5, 7, 11, 13, 17

‚ùå Not prime:
             1 (only one factor)
             4 (1,2,4)
             9 (1,3,9)

2Ô∏è‚É£ What are Prime Factors?
--> Prime factors are the prime numbers that multiply to give a number.

Example:
Number = 60
Prime factorization = 2 √ó 2 √ó 3 √ó 5
So prime factors of 60 ‚Üí {2, 3, 5}

3Ô∏è‚É£ Why Prime Factors Are Important?
--> Many problems depend on prime factorization:
 ‚úî GCD / LCM
‚úî Check if number is prime
‚úî Count divisors
‚úî Simplify fractions
‚úî Competitive programming
‚úî Interview coding rounds

4Ô∏è‚É£ Golden Rule (Interview Tip)
--> üëâ Every composite number can be broken into prime factors
--> üëâ You only need to check divisors up to ‚àön

5Ô∏è‚É£ Step-by-Step Approach to Find Prime Factors
Example: n = 84
Step 1Ô∏è‚É£ Start from smallest prime (2)
84 % 2 == 0 ‚Üí yes ‚Üí print 2
84 / 2 = 42

Step 2Ô∏è‚É£ Repeat same divisor
42 % 2 == 0 ‚Üí yes ‚Üí print 2
42 / 2 = 21

Step 3Ô∏è‚É£ Move to next number (3)
21 % 3 == 0 ‚Üí yes ‚Üí print 3
21 / 3 = 7

Step 4Ô∏è‚É£ Stop when divisor¬≤ > n
Remaining n = 7 ‚Üí prime

‚úÖ Prime Factors: 2 2 3 7


6Ô∏è‚É£ Java Algorithm (Core Logic)
üîπ Steps in Java
   1. Loop i from 2 to ‚àön
   2. While n % i == 0
      -->  print i
      -->  n = n / i
  3. After loop: if n > 1, print n

7Ô∏è‚É£ Java Code ‚Äì Prime Factorization

public class PrimeFactors {
    public static void printPrimeFactors(int n) {

        // Step 1: Handle factor 2
        while (n % 2 == 0) {
            System.out.print(2 + " ");
            n = n / 2;
        }

        // Step 2: Check odd factors from 3
        for (int i = 3; i * i <= n; i += 2) {
            while (n % i == 0) {
                System.out.print(i + " ");
                n = n / i;
            }
        }

        // Step 3: Remaining prime number
        if (n > 1) {
            System.out.print(n);
        }
    }

    public static void main(String[] args) {
        int number = 84;
        printPrimeFactors(number);
    }
}
Output : 2 2 3 7

8Ô∏è‚É£ Interview-Ready Explanation : 
--> ‚ÄúI repeatedly divide the number by the smallest possible prime factor starting from 2.
--> Once a factor divides the number completely, I keep dividing until it no longer does.
--> I only iterate till ‚àön because any factor greater than ‚àön must be paired with a smaller one.‚Äù

9Ô∏è‚É£ Common Prime-Based Problems & Approach

| Problem        | Approach                   |
| -------------- | -------------------------- |
| Check prime    | Loop till ‚àön               |
| Prime factors  | Repeated division          |
| GCD            | Prime factors or Euclid    |
| LCM            | Max power of prime factors |
| Count divisors | Use prime factor powers    |

üîü Reusable Template (Remember This)

while (n % 2 == 0) { ... }

for (int i = 3; i * i <= n; i += 2) {
    while (n % i == 0) { ... }
}

if (n > 1) { ... }

üî• PRIME NUMBERS & PRIME FACTORS ‚Äì PROBLEM SET (JAVA)
===========================================================

üü¢ PROBLEM 1: Check if a Number is Prime
üß† Logic : A number is prime if no divisor exists from 2 to ‚àön
‚úÖ Steps : 
    1. If n <= 1 ‚Üí not prime
    2. Loop from 2 to ‚àön
    3. If divisible ‚Üí not prime
üíª Java Code : 
public static boolean isPrime(int n) {
    if (n <= 1) return false;

    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
üé§ Interview Line : ‚ÄúI iterate till ‚àön because if n has a factor greater than ‚àön, it must also have a smaller one.‚Äù

üü¢ PROBLEM 2: Print All Prime Numbers up to N (Sieve of Eratosthenes)
üß† Logic : Mark multiples of primes as false

üíª Java Code : 
public static void printPrimes(int n) {
    boolean[] isPrime = new boolean[n + 1];

    for (int i = 2; i <= n; i++) {
        isPrime[i] = true;
    }

    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            System.out.print(i + " ");
        }
    }
}
Interview Tip : Time Complexity: O(n log log n)

üü¢ PROBLEM 3: Prime Factorization of a Number (Already learned, but revised)

public static void primeFactors(int n) {
    while (n % 2 == 0) {
        System.out.print(2 + " ");
        n /= 2;
    }

    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            System.out.print(i + " ");
            n /= i;
        }
    }

    if (n > 1) System.out.print(n);
}

üü¢ PROBLEM 4 : Count Total Number of Divisors
üß† Formula --> If: n = p1^a √ó p2^b √ó p3^c
Total divisors : (a+1)(b+1)(c+1)

üíª Java Code
public static int countDivisors(int n) {
    int count = 1;

    for (int i = 2; i * i <= n; i++) {
        int power = 0;

        while (n % i == 0) {
            n /= i;
            power++;
        }

        if (power > 0) {
            count *= (power + 1);
        }
    }

    if (n > 1) {
        count *= 2;
    }

    return count;
}

üü¢ PROBLEM 5: Find GCD Using Prime Factors
üß† Logic : Take minimum power of common primes

üíª Simple Java (Efficient Way)

public static int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

üü¢ PROBLEM 6: Find LCM Using GCD
üß† Formula : LCM = (a √ó b) / GCD

public static int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;
}

üü¢ PROBLEM 7: Check if a Number has Exactly 2 Prime Factors
Example:
6 ‚Üí 2 √ó 3 ‚Üí YES
12 ‚Üí 2 √ó 2 √ó 3 ‚Üí NO

üíª Java Code
public static boolean hasTwoPrimeFactors(int n) {
    int count = 0;

    for (int i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            n /= i;
            count++;
        }
    }

    if (n > 1) count++;

    return count == 2;
}

üü¢ PROBLEM 8: Check if a Number is a Perfect Square using Prime Factors
üß† Rule : All prime powers must be even
public static boolean isPerfectSquare(int n) {
    for (int i = 2; i * i <= n; i++) {
        int power = 0;

        while (n % i == 0) {
            n /= i;
            power++;
        }

        if (power % 2 != 0) return false;
    }
    return n == 1;
}

üü¢ PROBLEM 9: Find Largest Prime Factor

public static int largestPrimeFactor(int n) {
    int maxPrime = -1;

    while (n % 2 == 0) {
        maxPrime = 2;
        n /= 2;
    }

    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            maxPrime = i;
            n /= i;
        }
    }

    if (n > 1) maxPrime = n;

    return maxPrime;
}

üü¢ PROBLEM 10: Count Prime Numbers in an Array

public static int countPrimes(int[] arr) {
    int count = 0;

    for (int num : arr) {
        if (isPrime(num)) {
            count++;
        }
    }
    return count;
}

üß† MASTER INTERVIEW STRATEGY
--> Whenever you see:
       1. Prime ‚Üí loop till ‚àön
       2. Factors ‚Üí repeated division
       3. Range ‚Üí Sieve
       4. GCD/LCM ‚Üí Euclid
