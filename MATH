Count the number of digits in a Number 
--------------------------------------

Q: How to count the number of  digits in a Number? 

Algorithms : 
     1. checks if digits exist.
     2. Remove the last digit(devided by 10)
     3. Increase value of count by 1(one)
     4. Repeate step 1 to step 3 till digit remains

Example : 
package com.practice;
import java.util.Scanner;

public class CountDigits {
    public static int countDigits(int n) {

        int count = 0;

        // Handle case when number is 0
        if (n == 0) {
            return 1;
        }
        // Convert negative number to positive manually
        if (n < 0) {
            n = -n;
        }

        // Count digits
        while (n > 0) {
            n = n / 10;   // remove last digit
            count++;      // increase count
        }

        return count;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the number: ");
        int n = scan.nextInt();

        int result = countDigits(n);
        System.out.println("Number of digits: " + result);
    }
}

-------------------
Factorial
--------------------
Q: Write a Java program to find the factorial of a given number without using any inbuilt functions.

Example : Iterative approach 

package com.practice;

import java.util.Scanner;

public class Factorial {

    public static long factorial(int n) {

        if (n < 0) {
            return -1; // factorial not defined
        }

        long res = 1;

        for (int i = 1; i <= n; i++) {
            res = res * i;
        }

        return res;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);

        System.out.print("Enter the number for factorial: ");
        int n = scan.nextInt();

        long result = factorial(n);

        if (result == -1) {
            System.out.println("Factorial is not defined for negative numbers.");
        } else {
            System.out.println("Factorial of " + n + " is: " + result);
        }
    }
}

Note :
Q1Ô∏è‚É£ What is factorial?

üëâ Factorial of a number n is the product of all positive integers from 1 to n.

Q2Ô∏è‚É£ What is the factorial of 0?

üëâ 0! = 1

Q3Ô∏è‚É£ Why do we start result as 1?

üëâ Because factorial involves multiplication, and 1 is the identity for multiplication.

Q4Ô∏è‚É£ Can factorial be calculated for negative numbers?

üëâ No, factorial is not defined for negative numbers.

Q5Ô∏è‚É£ Why did you use long instead of int?

üëâ Because factorial values grow very fast and int overflows after 12!.

Q6Ô∏è‚É£ What is the difference between iterative and recursive factorial?

üëâ Iterative uses loops, recursion uses function calls. Iterative is more memory-efficient.

-----------------------
Trailing zeros : 
------------------
Q: üëâ ‚ÄúWrite a Java program to find the number of trailing zeroes in the factorial of a given number using an efficient algorithm.‚Äù

Example : 

package com.practice;

import java.util.Scanner;

public class TrailingZeros {

    static int trailingZeros(int n) {

        if (n < 0) {
            return -1; // not defined
        }

        int res = 0;
        int powerOf5 = 5;

        while (n >= powerOf5) {
            res = res + (n / powerOf5);
            powerOf5 = powerOf5 * 5;
        }

        return res;
    }

    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the number: ");
        int n = scan.nextInt();

        int result = trailingZeros(n);

        if (result == -1) {
            System.out.println("Trailing zeroes not defined for negative numbers.");
        } else {
            System.out.println("Trailing zeroes in " + n + "! = " + result);
        }
    }
}

Note : ‚ÄúTrailing zeroes in factorial depend on the number of factors of 5, so I sum n divided by powers of 5.‚Äù

Q: Why not count 2s?
A: Because factors of 2 are always more than factors of 5 in factorials.

===========================================GCD/HCF==========================================================================
Three way solve : 
1. Bruteforce Algorithm :
------------------------
a. Find the minimum of both A & B 
b. Use for loop and start from  `i = m` and go till one 
c. Inside the loop , check if  `i` is a common divisor .
d. If `i` is a common divisor , return `i` .

Example : 
package com.practice;
import java.util.Scanner;
public class BruteForceGCD {
    public static int bruteForceGCD(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negative numbers to positive (without inbuilt functions)
        if (a < 0) {
            a = -a;
        }
        if (b < 0) {
            b = -b;
        }

        // Find minimum manually
        int min;
        if (a < b) {
            min = a;
        } else {
            min = b;
        }

        // Brute-force GCD logic
        for (int i = min; i >= 1; i--) {
            if (a % i == 0 && b % i == 0) {
                return i;
            }
        }
        return 1;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int result = bruteForceGCD(a, b);
        System.out.println("GCD is: " + result);
        scan.close();
    }
}

2. Euclid's Algorithm : Efficient approach than brutforce algorithm
a. Find the larger number 
b. Replace the larger number by the difference between the larger and smaller number 
c. Repeat step `a` and `b` until both number become equal .

Example : 
package com.practice;
import java.util.Scanner;

public class EuclidAlgorithmGCD {
    public static int euclidAlgorithmGcd(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negatives to positive (no inbuilt functions)
        if (a < 0) a = -a;
        if (b < 0) b = -b;

        // Euclidean Algorithm using subtraction
        while (a != b) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
        return a; // or b (both are same)
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int res = euclidAlgorithmGcd(a, b);
        System.out.println("GCD is: " + res);
        scan.close();
    }
}

3. Most Optimised Euclid's Algorithm : given by GABRIEL LAME .

üìå Algorithm: GCD Using Euclidean Algorithm (Modulo Method) , // logrithimc time complexity
Step 1: Read two integers a and b.
Step 2: If a is equal to 0, return b as the GCD.
Step 3: If b is equal to 0, return a as the GCD.
Step 4: If a is negative, convert it to positive.
Step 5: If b is negative, convert it to positive.
Step 6: Repeat the following steps while both a and b are not equal to 0:
  --> If a is greater than b, replace a with a % b.
  --> Otherwise, replace b with b % a.
Step 7: When the loop ends, one of the numbers becomes 0.
Step 8: If a is not equal to 0, return a as the GCD; otherwise, return b.

package com.practice;
import java.util.Scanner;

public class EuclidAlgorithmGCD {

    public static int euclidAlgorithmGcd(int a, int b) {

        // Handle zero cases
        if (a == 0) return b;
        if (b == 0) return a;

        // Convert negatives to positive (no inbuilt functions)
        if (a < 0) a = -a;
        if (b < 0) b = -b;

        // Euclidean Algorithm using modulo(%)                                Most Efficient approach 
        while (a != 0 && b !=0) {
            if (a > b) {
                a = a % b;
            } else {
                b = b % a;
            }
        }
        if(a !=0){
            return a;
        }else{
            return b;
        }
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter the first number:");
        int a = scan.nextInt();

        System.out.println("Enter the second number:");
        int b = scan.nextInt();

        int res = euclidAlgorithmGcd(a, b);
        System.out.println("GCD is: " + res);
        scan.close();
    }
}
--------------------------------------------------------------------------------------------------------------------
üìå What is LCM?
--> LCM (Least Common Multiple) of two numbers is the smallest positive number that is divisible by both numbers.

üîπ Key Interview Formula (VERY IMPORTANT)
   -------------------------------
  |  LCM(a*b) = |a*b| / GCD(a,b) |
  --------------------------------
--> üëâ This is the most efficient and expected approach in interviews.

üß† Step-by-Step Algorithm (Using GCD) : 

Step 1: Read two integers a and b.
Step 2: If either a or b is 0, return 0 as LCM.
Step 3: Convert negative numbers to positive.
Step 4: Find GCD(a, b) using Euclidean Algorithm.
Step 5: Compute
LCM = (a * b) / GCD
Step 6: Return the LCM.

Example : 
package com.practice;
import java.util.Scanner;

public class LCMUsingGCD {

    // GCD using Euclidean Algorithm
    public static int gcd(int a, int b) {

        if (a == 0) return b;
        if (b == 0) return a;

        if (a < 0) a = -a;
        if (b < 0) b = -b;

        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    // LCM method
    public static int lcm(int a, int b) {
        if (a == 0 || b == 0) {
            return 0;
        }
        int gcdValue = gcd(a, b);
        return (a * b) / gcdValue;
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        System.out.println("Enter first number:");
        int a = scan.nextInt();

        System.out.println("Enter second number:");
        int b = scan.nextInt();

        int result = lcm(a, b);
        System.out.println("LCM is: " + result);
        scan.close();
    }
}

