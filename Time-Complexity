â±ï¸ Time Complexity â€” Interview-Depth Explanation
--------------------------------------------------
1ï¸âƒ£ What is Time Complexity?
--> Time Complexity measures how the execution time of an algorithm grows as input size increases.
ğŸ“Œ Key point for interview : Time Complexity is not actual time (seconds), it is the rate of growth of operations.

ğŸ“Œ What is Frequency Count?
--> ğŸ‘‰ Count how many times each statement executes as a function of input size n.
--> Then: Convert that count into Big-O Time Complexity

ğŸŸ¢ Example 1: Single Loop (VERY BASIC)
int sum = 0;              // (1)
for(int i = 0; i < n; i++) {   // (2)
    sum = sum + i;        // (3)
}
Step 1ï¸âƒ£ Count Each Statement
| Statement       | Frequency |
| --------------- | --------- |
| `sum = 0`       | 1         |
| `i = 0`         | 1         |
| `i < n`         | n + 1     |
| `i++`           | n         |
| `sum = sum + i` | n         |

Step 2ï¸âƒ£ Total Frequency
T(n) = 1 + 1 + (n + 1) + n + n
T(n) = 3n + 3

Step 3ï¸âƒ£ Convert to Big-O
--> Ignore constants
--> Keep highest order term
âœ… Final Time Complexity = O(n)

ğŸŸ¢ Example 2: Nested Loop (IMPORTANT)   OUTER LOOP  INNER LOOP
for(int i = 0; i < n; i++) {             n+1          --------    
    for(int j = 0; j < n; j++) {         n      *      (n+1)
        System.out.println("*");         n      *        n
    }
    System.out.println();             n             --------
}
Time Complexity : n+1 + n*(n+1) + n*n + n = 2n+1+nÂ²+n+nÂ² = 3n+1+2nÂ² = n+nÂ²= â¡ï¸ Time Complexity = O(nÂ²) âœ…

ğŸŸ¢ Example 3: triangular nested loop (n=5)                   i     |           j        |    No. of times j executed
for(int i = 0; i < n; i++) {             n+1                  0     |  0            +1   |     1      + 1 (termination condition)
    for(int j = 0; j <=i; j++) {         n(n + 1) / 2 +n      1     |  0,1          +1   |     2      + 1
        System.out.println("*");         n(n + 1) / 2         2     |  0,1,2        +1   |     3      + 1
    }                                                         3     |  0,1,2,3      +1   |     4      + 1
    System.out.println();                n                    4     |  0,1,2,3,4    +1   |     5      + 1
} 

Proper frequency counts:
| Component            | Frequency                                                  |
| -------------------- | -----------------------------------------------------------|
| Outer loop condition | n + 1                                                      |
| Inner loop condition | n(n + 1) / 2 + n since (1+2+3+4+5) + 5 = n(n + 1) / 2 + n  |
| Inner println        | n(n + 1) / 2     since 1+2+3....+n = n(n+1)/2              |
| Outer println        | n                                                          |

Time Complexity T(n) = (n + 1) + ((nÂ² + n)/2 + n) + (nÂ² + n)/2 + n 
                T(n) = (n + 1) + (nÂ²/2 + n/2 + n) + (nÂ²/2 + n/2) + n
                T(n) = (nÂ²/2 + nÂ²/2) + (n/2 + n/2 + n + n + n) + 1 = nÂ² + 4n + 1
                T(n) = O(nÂ²)

Step 1ï¸âƒ£ Simplify each group
First group : nÂ²/2 + nÂ²/2 = nÂ²
Second group : n/2 + n/2 = n
So : n/2 + n/2 + n + n + n
= n + n + n + n
= 4n
Constant term : + 1
Step 2ï¸âƒ£ Final Simplified Form
T(n) = nÂ² + 4n + 1

ğŸŸ¢ Example 4:Non-Linear Loop â€” O(âˆšn)       i    |    p            Termination condition : p > n                     
                                     -----------------------                              k(k+1)/2 > n
for(int i=0; p<=n; i++){                   0     |     0                                  kÂ²+k/2 > n    Ignore constants 
  p = p + i;                               1     |    0+1                                 kÂ²+k > n      Ignore lower terms
}                                          2     |   0+1+2                                kÂ² > n        Take square root
 1ï¸âƒ£ Understand the loop structure         3     |   0+1+2+3                              âˆš(kÂ²) > âˆšn
 The loop termination depends on p.        .     |      .                                 k > âˆšn
 p increases by i in each iteration.       .     |      .                                 Time Complexity = O(âˆšn) efficient time complexity
 p grows as the sum of natural numbers.    .     |      .
 Therefore, the loop runs âˆšn times.        K     |   0+1+2+3+....+k (sum of natural number)     

Time complexity order (ascending â†’ descending) : O(âˆšn) < O(n) < O(nÂ²) < O(nÂ³)

ğŸŸ¢ Example 4:                            
for (int i = 1; i < n; i = i * 2) {  |   Iteration             i value                              |  Termination condition : 2áµ >= n 
    // statements                    |--------------------------------------------------------------|                        2áµ = n              Skip termination iteration
}                                    |   1                      1 * 2                           = 2 |                        log(2áµ)   = log n   Take log on both sides:
                                     |   2                      1 * 2 * 2                       = 2Â²|                        logâ‚‚(2áµ)  = logâ‚‚ n  Change of base:since base is 2
                                     |   3                      1 * 2 * 2 * 2                   = 2Â³|                        k logâ‚‚(2) = logâ‚‚ n   Since logâ‚‚(2) = 1:
                                     |   4                      1 * 2 * 2 * 2 * 2               = 2â´|                            k     = logâ‚‚ n
                                     |   ......                           ......                    |
                                     |    k                     1 Ã— 2 Ã— 2 Ã— ... Ã— 2   (k times) = 2áµ|         Time complexity : T(k) = O(log n)    (Base of log is ignored in Big-O)

ğŸ§  Interview Tip
Whenever you see: i = i * 2 or i = i / 2
ğŸ‘‰ Immediately think: O(log n)

ğŸŸ¢ Example 4:
for (int i = n; i >= 1; i = i / 2) {
    // statements
}
1ï¸âƒ£ Understand the loop structure
| Part           | Explanation                                  |
| -------------- | -------------------------------------------- |
| Initialization | `i = n` âœ…                                   |
| Condition      | `i >= 1` â— (loop runs while i is at least 1) |
| Update         | `i = i / 2` â— (i halves each iteration)      |

2ï¸âƒ£ Trace the values of i
| Iteration | i value                         |
| --------- | ------------------------------- |
| 1         | n                               |
| 2         | n / 2                           |
| 3         | n / 2Â²                          |
| 4         | n / 2Â³                          |
| ...       | ...                             |
| k         | n / 2^k  (or the smallest integer â‰¥ 1) |

3ï¸âƒ£ Termination condition
Loop stops when: i < 1
After k iterations: n / 2áµ < 1

4ï¸âƒ£ Solve for k
Multiply both sides by 2áµ: n < 2áµ
Take log base 2: logâ‚‚(n) < logâ‚‚(2áµ)
Apply log rule: logâ‚‚(n) < k Â· logâ‚‚(2)
Since logâ‚‚(2) = 1:
k > logâ‚‚(n)

5ï¸âƒ£ Number of iterations
k â‰ˆ logâ‚‚(n)

6ï¸âƒ£ Time Complexity
T(n) = O(log n)


2ï¸âƒ£ Why Interviewers Care?
--> Interviewers use time complexity to check:
--> Can you analyze performance
--> Can you choose optimal algorithms
--> Can you scale applications (very important for backend roles like yours)

3ï¸âƒ£ How Time Complexity is Represented?
--> Using Big-O Notation
| Notation   | Meaning      |
| ---------- | ------------ |
| O(1)       | Constant     |
| O(log n)   | Logarithmic  |
| O(n)       | Linear       |
| O(n log n) | Linearithmic |
| O(nÂ²)      | Quadratic    |
| O(2â¿)      | Exponential  |

ğŸ“Œ Interview line: Big-O describes the upper bound (worst-case) time complexity.

4ï¸âƒ£ Types of Time Complexity
1. Best Case
2. Average Case
3. Worst Case (MOST IMPORTANT)

ğŸ“Œ Interviewers usually ask for worst-case

Example:
// Searching in array
for(int i=0;i<n;i++){
    if(arr[i]==x) return i;
}
| Case    | Time |
| ------- | ---- |
| Best    | O(1) |
| Average | O(n) |
| Worst   | O(n) |

5ï¸âƒ£ Common Time Complexities with Examples

ğŸŸ¢ O(1) â€” Constant Time
--> Execution time does not depend on input size.

int x = arr[5]; // INPUT=5
ğŸ“Œ Examples:
Access array element
HashMap get()

Interview Tip:Even if input size is 1 million â†’ still O(1)

ğŸŸ¢ O(log n) â€” Logarithmic Time
--> Input reduces by half each step.

// Binary Search
while(low <= high){
    int mid = (low + high) / 2;
    if(arr[mid] == key) return mid;
    else if(key < arr[mid]) high = mid - 1;
    else low = mid + 1;
}
ğŸ“Œ Rule: If you divide input by 2 â†’ O(log n)

 Tricky Interview Questions FOR Logarithmic Time : 
â“ What is time complexity of this?

for(int i=1;i<n;i=i*2){
    System.out.println(i);
}
âœ”ï¸ Answer: O(log n)

â“ What about this?
for(int i=0;i<n;i++){
    for(int j=1;j<n;j=j*2){
        System.out.println(i+j);
    }
}
âœ”ï¸ O(n log n)

ğŸŸ¢ O(n) â€” Linear Time
--> Loop runs n times.

for(int i=0;i<n;i++){
    System.out.println(arr[i]);
}

ğŸ“Œ Examples:
--> Traversing array
--> Searching unsorted array

ğŸŸ¢ O(n log n) â€” Linearithmic
--> Combination of divide + process n elements
// Merge Sort
O(n log n)

ğŸ“Œ Examples:
--> Merge Sort
--> Quick Sort (average)

ğŸŸ¢ O(nÂ²) â€” Quadratic
--> Nested loops.
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        System.out.println(i + j);
    }
}
ğŸ“Œ Examples:
--> Bubble Sort
--> Selection Sort
âš ï¸ Interview warning: Avoid O(nÂ²) for large input

ğŸŸ¢ O(2â¿) â€” Exponential (VERY BAD)
--> Each input creates two recursive calls.
int fib(int n){
    if(n<=1) return n;
    return fib(n-1) + fib(n-2);
}
ğŸ“Œ Used in:
--> Brute force recursion
--> Backtracking

6ï¸âƒ£ How to Calculate Time Complexity (STEP-BY-STEP) : 
-----------------------------------------------------
âœ… Rule 1: Ignore constants
--> O(3n + 5) â†’ O(n)

âœ… Rule 2: Nested loops â†’ Multiply
for(i=0;i<n;i++)
  for(j=0;j<n;j++)

â†’ O(nÂ²)

âœ… Rule 3: Sequential loops â†’ Add
for(i=0;i<n;i++) â†’ O(n)
for(j=0;j<n;j++) â†’ O(n)

Total â†’ O(2n) â†’ O(n)

âœ… Rule 4: Drop lower order terms
--> O(nÂ² + n + 1) â†’ O(nÂ²)













